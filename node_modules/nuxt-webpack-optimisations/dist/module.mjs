import { extendWebpackConfig, isNuxt3, isNuxt2, defineNuxtModule } from '@nuxt/kit';
import consola from 'consola';
import SpeedMeasurePlugin from 'speed-measure-webpack-plugin';
import { ESBuildMinifyPlugin } from 'esbuild-loader';
import { cpus } from 'os';

const version = "2.2.0";

const NAME = "nuxt-webpack-optimisations";
const NUXT_CONFIG_KEY = "webpackOptimisations";
const defaultOptions = {
  profile: void 0,
  debug: false,
  measure: false,
  measureMode: "all",
  esbuildMinifyOptions: {
    client: {
      target: "es2015"
    },
    server: {
      target: "node14"
    },
    modern: {
      target: "es2015"
    }
  },
  esbuildLoaderOptions: {
    client: {
      target: "es2015"
    },
    server: {
      target: "node14"
    },
    modern: {
      target: "es2015"
    }
  },
  features: {
    postcssNoPolyfills: true,
    esbuildLoader: true,
    esbuildMinifier: true,
    imageFileLoader: true,
    webpackOptimisations: true,
    cacheLoader: true,
    hardSourcePlugin: false,
    parallelPlugin: false
  }
};

const defineAugmentation = (augmentation) => augmentation;
const deny = (reason) => ({ forward: "deny", reason });

const useSpeedMeasurePlugin = defineAugmentation(({ logger, options, dev, nuxt }) => ({
  dev: true,
  policy() {
    if (!options.measure)
      return deny("measure not enabled");
    if (!nuxt.options.ssr) {
      options.measure = false;
      return deny("SSR mode is off");
    }
    if (process.env.NODE_ENV === "test") {
      options.measure = false;
      return deny("testing environment");
    }
    return dev;
  },
  setup() {
    const defaults = {
      outputFormat: "human"
    };
    const measureOptions = {
      ...defaults,
      ...typeof options.measure === "boolean" ? {} : options.measure
    };
    const smp = new SpeedMeasurePlugin(measureOptions);
    extendWebpackConfig((config) => {
      if (config.name === options.measureMode || options.measureMode === "all") {
        smp.wrap(config);
        logger.info(`SpeedMeasurePlugin is enabled for \`${config.name}\`. Build time may be effected.`);
      }
    });
  }
}));

const useEsbuildOverBabel = defineAugmentation(({ name, logger, nuxt, options, dev }) => ({
  featureKey: "esbuildLoader",
  dev: true,
  policy() {
    if (isNuxt3(nuxt))
      ;
  },
  setup() {
    extendWebpackConfig((config) => {
      config.module.rules.map((rule) => {
        if (!rule.use || !Array.isArray(rule.use) || !rule.test)
          return rule;
        const test = rule.test;
        const isTypescript = test.test("test.ts");
        const isJavascript = test.test("test.js");
        if (!isJavascript && !isTypescript)
          return rule;
        const babelLoaderIndex = rule.use.findIndex((use) => use.loader.includes("babel-loader"));
        if (babelLoaderIndex === -1)
          return rule;
        const esbuildLoader = {
          loader: "esbuild-loader",
          options: {
            loader: "js",
            ...options.esbuildLoaderOptions[config.name]
          }
        };
        if (dev && isJavascript) {
          logger.debug(`\`${name}:${config.name}\` Swapping babel-loader for esbuild-loader for ${rule.test}.`);
          rule.use.splice(babelLoaderIndex, 1, esbuildLoader);
          return rule;
        }
        esbuildLoader.options.loader = "ts";
        rule.use.splice(babelLoaderIndex, 1, esbuildLoader);
        const tsLoaderIndex = rule.use.findIndex((use) => use.loader.includes("ts-loader"));
        if (tsLoaderIndex !== -1) {
          logger.debug(`\`${name}:${config.name}\` Swapping ts-loader for esbuild-loader for ${rule.test}.`);
          rule.use.splice(tsLoaderIndex, 1);
        }
        return rule;
      });
    });
  }
}));

const useEsbuildMinifier = defineAugmentation(({ logger, name, options, nuxt }) => ({
  featureKey: "esbuildMinifier",
  dev: false,
  policy() {
    if (isNuxt3(nuxt))
      ;
  },
  setup() {
    nuxt.options.build.terser = false;
    extendWebpackConfig((config) => {
      logger.debug(`\`${name}:${config.name}\` Swapping TerserPlugin for ESBuildMinifyPlugin.`);
      config.optimization.minimizer = [
        new ESBuildMinifyPlugin(options.esbuildMinifyOptions[config.name])
      ];
    });
  }
}));

const useFileLoaderForImagesInDev = defineAugmentation(({ logger, name }) => ({
  featureKey: "imageFileLoader",
  dev: true,
  setup() {
    extendWebpackConfig((config) => {
      const imgLoaders = config.module.rules.filter((r) => r.test && !r.resourceQuery && (".png".match(r.test) || ".jpg".match(r.test)));
      if (!imgLoaders.length)
        return;
      const firstImgLoader = imgLoaders[0];
      config.module.rules = config.module.rules.filter((item) => item !== firstImgLoader);
      logger.debug(`\`${name}:${config.name}\` Swapping url-loader for file-loader with test ${firstImgLoader.test}.`);
      config.module.rules.push({
        test: firstImgLoader.test,
        use: [
          {
            loader: "file-loader",
            options: {
              name: "[path][name].[ext]",
              esModule: false
            }
          }
        ]
      });
    });
  }
}));

const useGenericWebpackOptimisations = defineAugmentation(({ nuxt, dev }) => ({
  featureKey: "webpackOptimisations",
  setup() {
    extendWebpackConfig((config) => {
      if (!config.output || !config.resolve || !config.optimization)
        return;
      config.output.pathinfo = false;
      if (isNuxt2(nuxt))
        config.output.futureEmitAssets = true;
      config.resolve.cacheWithContext = false;
      if (dev) {
        config.optimization.removeAvailableModules = false;
        config.optimization.removeEmptyChunks = false;
        config.optimization.splitChunks = false;
        config.optimization.runtimeChunk = false;
      }
    });
  }
}));

const useDisableModernModeDev = defineAugmentation(({ nuxt, nuxtOptions }) => ({
  dev: true,
  policy() {
    if (isNuxt3(nuxt))
      ;
  },
  setup() {
    nuxtOptions.modern = false;
  }
}));

const useNuxtBuildCache = defineAugmentation(({ options, nuxtOptions }) => ({
  featureKey: "cacheLoader",
  policy() {
    if (options.measure)
      return deny("optimisations disabled while `measure` is enabled");
  },
  setup() {
    nuxtOptions.build.cache = true;
  }
}));

const cpuCount = cpus().length;
const useNuxtBuildParallel = defineAugmentation(({ options, logger, nuxtOptions }) => ({
  featureKey: "parallelPlugin",
  policy() {
    if (cpuCount <= 1)
      return deny("Not enough CPU cores.");
    if (options.measure)
      return deny("optimisations disabled while `measure` is enabled");
  },
  setup() {
    nuxtOptions.build.parallel = true;
    logger.debug(`thread-loader has ${cpuCount} CPU cores.`);
  }
}));

const useNuxtBuildHardSource = defineAugmentation(({ options, nuxtOptions }) => ({
  dev: true,
  featureKey: "hardSourcePlugin",
  policy() {
    if (options.measure)
      return deny("optimisations disabled while `measure` is enabled");
  },
  setup() {
    nuxtOptions.build.hardSource = true;
  }
}));

const useDisableDevPostcssPresetEnv = defineAugmentation(({ nuxtOptions, nuxt }) => ({
  featureKey: "postcssNoPolyfills",
  dev: true,
  policy() {
    if (nuxtOptions.build.postcss === false)
      return deny("postcss is disabled");
  },
  setup() {
    if (isNuxt3(nuxt)) {
      if (!nuxtOptions.build.postcss.postcssOptions.plugins)
        nuxtOptions.build.postcss.postcssOptions.plugins = {};
      nuxtOptions.build.postcss.postcssOptions.plugins.autoprefixer = false;
    } else {
      if (!nuxtOptions.build.postcss.plugins)
        nuxtOptions.build.postcss.plugins = {};
      nuxtOptions.build.postcss.plugins["postcss-preset-env"] = false;
      nuxtOptions.build.postcss.plugins.autoprefixer = false;
    }
  }
}));

const module = defineNuxtModule({
  meta: {
    name: NAME,
    version,
    configKey: NUXT_CONFIG_KEY
  },
  defaults: defaultOptions,
  async setup(webpackOptimisationOptions, nuxt) {
    const logger = consola.withScope(NAME);
    if (webpackOptimisationOptions.debug) {
      logger.level = 4;
    }
    if (webpackOptimisationOptions.profile) {
      logger.warn(`${NAME} the "profile" config has been deprecated. Use "risky" instead.`);
      if (webpackOptimisationOptions.profile === "risky") {
        webpackOptimisationOptions.features.hardSourcePlugin = true;
        webpackOptimisationOptions.features.parallelPlugin = true;
      } else if (webpackOptimisationOptions.profile === "safe") {
        webpackOptimisationOptions.features.postcssNoPolyfills = false;
      }
    }
    if (webpackOptimisationOptions.esbuildLoaderOptions?.target) {
      const target = webpackOptimisationOptions.esbuildLoaderOptions.target;
      webpackOptimisationOptions.esbuildLoaderOptions = {
        client: { target },
        server: { target },
        modern: { target }
      };
    }
    if (webpackOptimisationOptions.esbuildMinifyOptions?.target) {
      const target = webpackOptimisationOptions.esbuildMinifyOptions.target;
      webpackOptimisationOptions.esbuildMinifyOptions = {
        client: { target },
        server: { target },
        modern: { target }
      };
    }
    const options = webpackOptimisationOptions;
    if (isNuxt2(nuxt) && nuxt.options.buildModules.includes("nuxt-vite")) {
      logger.warn(`\`${NAME}\` is enabled with \`nuxt-vite\`. Please remove ${NAME} from your buildModules.`);
      return;
    }
    if (isNuxt3(nuxt) && nuxt.options.vite !== false) {
      logger.error(`\`${NAME}\` is only for webpack builds. Please remove ${NAME} from your buildModules.`);
      return;
    }
    await nuxt.callHook("webpackOptimisations:options", options);
    const augmentations = {
      useSpeedMeasurePlugin,
      useEsbuildOverBabel,
      useEsbuildMinifier,
      useFileLoaderForImagesInDev,
      useGenericWebpackOptimisations,
      useDisableDevPostcssPresetEnv,
      useDisableModernModeDev,
      useNuxtBuildCache,
      useNuxtBuildParallel,
      useNuxtBuildHardSource
    };
    Object.values(augmentations).map((fn, i) => {
      const name = Object.keys(augmentations)[i];
      return fn({
        logger,
        name,
        nuxt,
        nuxtOptions: nuxt.options,
        options,
        dev: nuxt.options.dev
      });
    }).forEach((fn, i) => {
      const name = Object.keys(augmentations)[i];
      let disabledReason = false;
      if (typeof fn.dev !== "undefined") {
        if (fn.dev && !nuxt.options.dev)
          disabledReason = "dev only";
        else if (!fn.dev && nuxt.options.dev)
          disabledReason = "non-dev only";
      }
      if (typeof fn.featureKey === "string") {
        if (!options.features[fn.featureKey])
          disabledReason = `features.${fn.featureKey} is false`;
      }
      if (typeof fn.policy === "function") {
        const resp = fn.policy();
        if (typeof resp === "object" && resp.forward === "deny")
          disabledReason = resp.reason;
      }
      if (disabledReason) {
        logger.debug(`\`${name}\` disabled: ${disabledReason}.`);
        return;
      }
      logger.debug(`\`${name}\` enabled.`);
      fn.setup();
    });
  }
});

export { module as default };
