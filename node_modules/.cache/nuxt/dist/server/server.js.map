{"version":3,"file":"server.js","sources":["webpack:///server.js"],"sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \tvar installedChunks = {\n/******/ \t\t0: 0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId) {\n/******/ \t\tvar promises = [];\n/******/\n/******/\n/******/ \t\t// require() chunk loading for javascript\n/******/\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] !== 0) {\n/******/ \t\t\tvar chunk = require(\"./\" + ({\"1\":\"components/v-about\",\"2\":\"components/v-contact\",\"3\":\"components/v-footer\",\"4\":\"components/v-footer-social-link\",\"5\":\"components/v-h2\",\"6\":\"components/v-header\",\"7\":\"components/v-header-background\",\"8\":\"components/v-loader\",\"9\":\"components/v-menu\",\"10\":\"components/v-navbar\",\"11\":\"components/v-pointer\",\"12\":\"components/v-scroll-down\",\"13\":\"components/v-work\",\"14\":\"components/v-work-item\",\"15\":\"pages/index\",\"16\":\"pages/works/brg\",\"17\":\"pages/works/heating-pad\",\"18\":\"pages/works/workPage\"}[chunkId]||chunkId) + \".js\");\n/******/ \t\t\tvar moreModules = chunk.modules, chunkIds = chunk.ids;\n/******/ \t\t\tfor(var moduleId in moreModules) {\n/******/ \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t\t}\n/******/ \t\t\tfor(var i = 0; i < chunkIds.length; i++)\n/******/ \t\t\t\tinstalledChunks[chunkIds[i]] = 0;\n/******/ \t\t}\n/******/ \t\treturn Promise.all(promises);\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/home/_nuxt/\";\n/******/\n/******/ \t// uncaught error handler for webpack runtime\n/******/ \t__webpack_require__.oe = function(err) {\n/******/ \t\tprocess.nextTick(function() {\n/******/ \t\t\tthrow err; // catch this error by using import().catch()\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 15);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"vue\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(URLSearchParams) {\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = { overflow: \"Overflow Error\", \"not-basic\": \"Illegal Input\", \"invalid-input\": \"Invalid Input\" };\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_BRACKET_OPEN_RE = /%5B/gi;\nconst ENC_BRACKET_CLOSE_RE = /%5D/gi;\nconst ENC_CARET_RE = /%5E/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7B/gi;\nconst ENC_PIPE_RE = /%7C/gi;\nconst ENC_CURLY_CLOSE_RE = /%7D/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2F/gi;\nconst ENC_ENC_SLASH_RE = /%252F/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return encode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch (_err) {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(paramsStr = \"\") {\n  const obj = {};\n  if (paramsStr[0] === \"?\") {\n    paramsStr = paramsStr.substr(1);\n  }\n  for (const param of paramsStr.split(\"&\")) {\n    const s = param.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decode(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (obj[key]) {\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = [obj[key], value];\n      }\n    } else {\n      obj[key] = value;\n    }\n  }\n  return obj;\n}\nfunction encodeQueryItem(key, val) {\n  if (!val) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(val)) {\n    return val.map((_val) => `${encodeQueryKey(key)}=${encodeQueryValue(_val)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(val)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).map((k) => encodeQueryItem(k, query[k])).join(\"&\");\n}\n\nclass $URL {\n  constructor(input = \"\") {\n    this.query = {};\n    if (typeof input !== \"string\") {\n      throw new TypeError(`URL input should be string received ${typeof input} (${input})`);\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        value.forEach((v) => p.append(name, v));\n      } else {\n        p.append(name, value || \"\");\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputStr) {\n  return [\"./\", \"../\"].some((str) => inputStr.startsWith(str));\n}\nfunction hasProtocol(inputStr, acceptProtocolRelative = false) {\n  return /^\\w+:\\/\\/.+/.test(inputStr) || acceptProtocolRelative && /^\\/\\/[^/]+/.test(inputStr);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?/;\nfunction hasTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction withTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return s0 + \"/\" + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.substr(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((str) => str.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input.substr(_base.length) || \"/\";\n  }\n  return input;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const i of input.filter(isNonEmptyURL)) {\n    url = url ? withTrailingSlash(url) + withoutLeadingSlash(i) : i;\n  }\n  return url;\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const i of input.filter(isNonEmptyURL)) {\n    url.append(createURL(i));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  if (!hasProtocol(input, true)) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [protocol = \"\", auth, hostAndPath] = (input.replace(/\\\\/g, \"/\").match(/([^:/]+:)?\\/\\/([^/@]+@)?(.*)/) || []).splice(1);\n  const [host = \"\", path = \"\"] = (hostAndPath.match(/([^/?#]*)(.*)?/) || []).splice(1);\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol,\n    auth: auth ? auth.substr(0, auth.length - 1) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/]*)(:0-9+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const fullpath = parsed.pathname + (parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\") + parsed.hash;\n  if (!parsed.protocol) {\n    return fullpath;\n  }\n  return parsed.protocol + \"//\" + (parsed.auth ? parsed.auth + \"@\" : \"\") + parsed.host + fullpath;\n}\n\nexports.$URL = $URL;\nexports.cleanDoubleSlashes = cleanDoubleSlashes;\nexports.createURL = createURL;\nexports.decode = decode;\nexports.decodePath = decodePath;\nexports.decodeQueryValue = decodeQueryValue;\nexports.encode = encode;\nexports.encodeHash = encodeHash;\nexports.encodeHost = encodeHost;\nexports.encodeParam = encodeParam;\nexports.encodePath = encodePath;\nexports.encodeQueryItem = encodeQueryItem;\nexports.encodeQueryKey = encodeQueryKey;\nexports.encodeQueryValue = encodeQueryValue;\nexports.getQuery = getQuery;\nexports.hasLeadingSlash = hasLeadingSlash;\nexports.hasProtocol = hasProtocol;\nexports.hasTrailingSlash = hasTrailingSlash;\nexports.isEmptyURL = isEmptyURL;\nexports.isNonEmptyURL = isNonEmptyURL;\nexports.isRelative = isRelative;\nexports.isSamePath = isSamePath;\nexports.joinURL = joinURL;\nexports.normalizeURL = normalizeURL;\nexports.parseAuth = parseAuth;\nexports.parseHost = parseHost;\nexports.parsePath = parsePath;\nexports.parseQuery = parseQuery;\nexports.parseURL = parseURL;\nexports.resolveURL = resolveURL;\nexports.stringifyParsedURL = stringifyParsedURL;\nexports.stringifyQuery = stringifyQuery;\nexports.withBase = withBase;\nexports.withLeadingSlash = withLeadingSlash;\nexports.withQuery = withQuery;\nexports.withTrailingSlash = withTrailingSlash;\nexports.withoutBase = withoutBase;\nexports.withoutLeadingSlash = withoutLeadingSlash;\nexports.withoutTrailingSlash = withoutTrailingSlash;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17)[\"URLSearchParams\"]))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent(\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */,\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options =\n    typeof scriptExports === 'function' ? scriptExports.options : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) {\n    // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n          injectStyles.call(\n            this,\n            (options.functional ? this.parent : this).$root.$options.shadowRoot\n          )\n        }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"gsap\");\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"vue-no-ssr\");\n\n/***/ }),\n/* 5 */,\n/* 6 */\n/***/ (function(module, exports) {\n\n// This file is intentionally left empty for noop aliases\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"vue-client-only\");\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"vue-router\");\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"property-information\");\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction isObject(val) {\n  return val !== null && typeof val === \"object\";\n}\nfunction _defu(baseObj, defaults, namespace = \".\", merger) {\n  if (!isObject(defaults)) {\n    return _defu(baseObj, {}, namespace, merger);\n  }\n  const obj = Object.assign({}, defaults);\n  for (const key in baseObj) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const val = baseObj[key];\n    if (val === null || val === void 0) {\n      continue;\n    }\n    if (merger && merger(obj, key, val, namespace)) {\n      continue;\n    }\n    if (Array.isArray(val) && Array.isArray(obj[key])) {\n      obj[key] = obj[key].concat(val);\n    } else if (isObject(val) && isObject(obj[key])) {\n      obj[key] = _defu(val, obj[key], (namespace ? `${namespace}.` : \"\") + key.toString(), merger);\n    } else {\n      obj[key] = val;\n    }\n  }\n  return obj;\n}\nfunction extend(merger) {\n  return (...args) => args.reduce((p, c) => _defu(p, c, \"\", merger), {});\n}\nconst defu = extend();\ndefu.fn = extend((obj, key, currentValue, _namespace) => {\n  if (typeof obj[key] !== \"undefined\" && typeof currentValue === \"function\") {\n    obj[key] = currentValue(obj[key]);\n    return true;\n  }\n});\ndefu.arrayFn = extend((obj, key, currentValue, _namespace) => {\n  if (Array.isArray(obj[key]) && typeof currentValue === \"function\") {\n    obj[key] = currentValue(obj[key]);\n    return true;\n  }\n});\ndefu.extend = extend;\n\nmodule.exports = defu;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\t\"__nuxt-error-page\": \"GvJoby3R+7yoknzQj1D2HA==\",\n\t\"error\": \"C+WgafTKQqEHQhNNxKnMfQ==\",\n\t\"title\": \"U6W6dSDzS4CCN0q9oLHr3w==\",\n\t\"description\": \"pAtPBAC6uNKNdNaCglVBeA==\",\n\t\"logo\": \"Unb5t2lR0okIiR2I686ImA==\"\n};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\t\"nuxt-progress\": \"_5-y9ixR+fv3SLGi9GxOn8Q==\",\n\t\"nuxt-progress-notransition\": \"_1gBNXQBZ7kt9ibh1cJMG3g==\",\n\t\"nuxt-progress-failed\": \"NQIw2WiubjCmzrBmj7Nnaw==\"\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"node-fetch\");\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"vue-meta\");\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(16);\nmodule.exports = __webpack_require__(25);\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\nglobal.installComponents = function (component, components) {\n  var options = typeof component.exports === 'function'\n    ? component.exports.extendOptions\n    : component.options\n\n  if (typeof component.exports === 'function') {\n    options.components = component.exports.options.components\n  }\n\n  options.components = options.components || {}\n\n  for (var i in components) {\n    options.components[i] = options.components[i] || components[i]\n  }\n\n\n  if (options.functional) {\n    provideFunctionalComponents(component, options.components)\n  }\n}\n\nvar functionalPatchKey = '_functionalComponents'\n\nfunction provideFunctionalComponents(component, components) {\n  if (component.exports[functionalPatchKey]) {\n    return\n  }\n  component.exports[functionalPatchKey] = true\n\n  var render = component.exports.render\n  component.exports.render = function (h, vm) {\n    return render(h, Object.assign({}, vm, {\n      _c: function (n, a, b) {\n        return vm._c(components[n] || n, a, b)\n      }\n    }))\n  }\n}\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"url\");\n\n/***/ }),\n/* 18 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/* harmony import */ var _cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_id_608a1420_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/* harmony import */ var _cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _cache_loader_dist_cjs_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_dist_cjs_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_id_d4ff419a_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\t\"has-scroll-smooth\": \"w-Ch6kPXU9UAV+wjFnjdRw==\",\n\t\"has-scroll-dragging\": \"pFQp4Vwq-gI-jbRJGm-w1g==\",\n\t\"c-scrollbar\": \"ZwCljrmdPluaQa8KgAfpyQ==\",\n\t\"has-scroll-scrolling\": \"PforPydjNTe4A44gobpwjQ==\",\n\t\"c-scrollbar_thumb\": \"_68O8KfpRxZZU9P2BQXdgZA==\"\n};\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\t\"ml-responsive\": \"NW7WlI41s4+v27pw-OSkSg==\",\n\t\"sr-only\": \"fTG71MQrIiHANAzyOHi1QA==\"\n};\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n// Exports\nmodule.exports = {\n\t\"token\": \"HtRjxF1xaEupAA7r39Gbhw==\",\n\t\"cdata\": \"X5TRN77+KjNHrzRcbB3hbg==\",\n\t\"comment\": \"YIdZ6yqSsO3fXzC7K+90oA==\",\n\t\"doctype\": \"Obkg9Y7Cehow1c8On84tZQ==\",\n\t\"prolog\": \"_4xCyRrbELMCC6WG0wqDgwQ==\",\n\t\"punctuation\": \"buib-4cBEJj4jwbMX7txcg==\",\n\t\"namespace\": \"RCKYUsRPoP1kA6TihYuVig==\",\n\t\"boolean\": \"r4xHJSpF21s-LZ5HecCXKw==\",\n\t\"constant\": \"gzV0E5tWvguFBMedxmWp0g==\",\n\t\"deleted\": \"YuAkaK-yy8oOV4CzcJQLpg==\",\n\t\"number\": \"_56WgSFNWfjX5-9hgQnURxQ==\",\n\t\"property\": \"hGSrffxxplyUSzfmrrF-RA==\",\n\t\"symbol\": \"-YWZUsA5Os+AWtlnuYf9jQ==\",\n\t\"tag\": \"zaueneN9gK3jxIuyKSnR-w==\",\n\t\"attr-name\": \"+rxfcWddi3wNUtyiBh5nXA==\",\n\t\"builtin\": \"TXSyi+R4R6c-Einsn4HGbg==\",\n\t\"char\": \"-KGne8zw4ebdcL8r0m77mA==\",\n\t\"inserted\": \"obQOh6tNl--xgMMks8QHgg==\",\n\t\"selector\": \"_5aykJ28cCz0UqMZZT0bsgA==\",\n\t\"string\": \"PsNnrp996lcD0HQRaBNbvw==\",\n\t\"language-css\": \"_5LrtQ3rlbedbC6wgbO7I6A==\",\n\t\"style\": \"qi28HUszkad89TMIDYDzfA==\",\n\t\"entity\": \"cJ5HlSKayyFT0Xt+EJAZlw==\",\n\t\"operator\": \"UDlgD3Ok5mRjtOq5lL0U2Q==\",\n\t\"url\": \"_4fXe3ShtFfACBEC+jHgvLg==\",\n\t\"atrule\": \"Ch97f+mILhw40cixQtuLCg==\",\n\t\"attr-value\": \"Eq-GdICzTkLY6Shd+BlGgw==\",\n\t\"keyword\": \"_2Clyk0yUWePZl1AebRWC4A==\",\n\t\"class-name\": \"FJ0SN3Ot6y4dY5pUaMGphQ==\",\n\t\"function\": \"b8sSTRNhrzsCIqpeORsqXQ==\",\n\t\"important\": \"KZZaspSh476wtZiB-X4KAg==\",\n\t\"regex\": \"_6NHHl-JkkRXU+w07owttCQ==\",\n\t\"variable\": \"_1hg3imlg9R0A5BQM4z0L-w==\",\n\t\"bold\": \"TWxB8U+8Ek0lI99ZWsoJDQ==\",\n\t\"italic\": \"cMjNr7WkwSaAyVlAwmqywA==\"\n};\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// NAMESPACE OBJECT: ./node_modules/.cache/nuxt/components/index.js\nvar components_namespaceObject = {};\n__webpack_require__.r(components_namespaceObject);\n__webpack_require__.d(components_namespaceObject, \"VAbout\", function() { return VAbout; });\n__webpack_require__.d(components_namespaceObject, \"VContact\", function() { return VContact; });\n__webpack_require__.d(components_namespaceObject, \"VFooterSocialLink\", function() { return VFooterSocialLink; });\n__webpack_require__.d(components_namespaceObject, \"VFooter\", function() { return VFooter; });\n__webpack_require__.d(components_namespaceObject, \"VH2\", function() { return VH2; });\n__webpack_require__.d(components_namespaceObject, \"VHeaderBackground\", function() { return VHeaderBackground; });\n__webpack_require__.d(components_namespaceObject, \"VHeader\", function() { return VHeader; });\n__webpack_require__.d(components_namespaceObject, \"VLoader\", function() { return VLoader; });\n__webpack_require__.d(components_namespaceObject, \"VMenu\", function() { return VMenu; });\n__webpack_require__.d(components_namespaceObject, \"VNavbar\", function() { return VNavbar; });\n__webpack_require__.d(components_namespaceObject, \"VPointer\", function() { return VPointer; });\n__webpack_require__.d(components_namespaceObject, \"VScrollDown\", function() { return VScrollDown; });\n__webpack_require__.d(components_namespaceObject, \"VWorkItem\", function() { return VWorkItem; });\n__webpack_require__.d(components_namespaceObject, \"VWork\", function() { return VWork; });\n\n// NAMESPACE OBJECT: ./node_modules/@nuxt/image/dist/runtime/providers/static.js\nvar static_namespaceObject = {};\n__webpack_require__.r(static_namespaceObject);\n__webpack_require__.d(static_namespaceObject, \"getImage\", function() { return static_getImage; });\n__webpack_require__.d(static_namespaceObject, \"supportsAlias\", function() { return static_supportsAlias; });\n\n// EXTERNAL MODULE: external \"vue\"\nvar external_vue_ = __webpack_require__(0);\nvar external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);\n\n// EXTERNAL MODULE: ./node_modules/ufo/dist/index.cjs\nvar dist = __webpack_require__(1);\n\n// EXTERNAL MODULE: external \"node-fetch\"\nvar external_node_fetch_ = __webpack_require__(13);\nvar external_node_fetch_default = /*#__PURE__*/__webpack_require__.n(external_node_fetch_);\n\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/middleware.js\nconst middleware = {};\n/* harmony default export */ var nuxt_middleware = (middleware);\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/utils.js\n\n\n\n// window.{{globals.loadedCallback}} hook\n// Useful for jsdom testing or plugins (https://github.com/tmpvar/jsdom#dealing-with-asynchronous-script-loading)\nif (false) {}\nfunction createGetCounter(counterObject, defaultKey = '') {\n  return function getCounter(id = defaultKey) {\n    if (counterObject[id] === undefined) {\n      counterObject[id] = 0;\n    }\n    return counterObject[id]++;\n  };\n}\nfunction empty() {}\nfunction globalHandleError(error) {\n  if (external_vue_default.a.config.errorHandler) {\n    external_vue_default.a.config.errorHandler(error);\n  }\n}\nfunction interopDefault(promise) {\n  return promise.then(m => m.default || m);\n}\nfunction hasFetch(vm) {\n  return vm.$options && typeof vm.$options.fetch === 'function' && !vm.$options.fetch.length;\n}\nfunction purifyData(data) {\n  if (true) {\n    return data;\n  }\n  return Object.entries(data).filter(([key, value]) => {\n    const valid = !(value instanceof Function) && !(value instanceof Promise);\n    if (!valid) {\n      console.warn(`${key} is not able to be stringified. This will break in a production environment.`);\n    }\n    return valid;\n  }).reduce((obj, [key, value]) => {\n    obj[key] = value;\n    return obj;\n  }, {});\n}\nfunction getChildrenComponentInstancesUsingFetch(vm, instances = []) {\n  const children = vm.$children || [];\n  for (const child of children) {\n    if (child.$fetch) {\n      instances.push(child);\n      continue; // Don't get the children since it will reload the template\n    }\n\n    if (child.$children) {\n      getChildrenComponentInstancesUsingFetch(child, instances);\n    }\n  }\n  return instances;\n}\nfunction applyAsyncData(Component, asyncData) {\n  if (\n  // For SSR, we once all this function without second param to just apply asyncData\n  // Prevent doing this for each SSR request\n  !asyncData && Component.options.__hasNuxtData) {\n    return;\n  }\n  const ComponentData = Component.options._originDataFn || Component.options.data || function () {\n    return {};\n  };\n  Component.options._originDataFn = ComponentData;\n  Component.options.data = function () {\n    const data = ComponentData.call(this, this);\n    if (this.$ssrContext) {\n      asyncData = this.$ssrContext.asyncData[Component.cid];\n    }\n    return {\n      ...data,\n      ...asyncData\n    };\n  };\n  Component.options.__hasNuxtData = true;\n  if (Component._Ctor && Component._Ctor.options) {\n    Component._Ctor.options.data = Component.options.data;\n  }\n}\nfunction sanitizeComponent(Component) {\n  // If Component already sanitized\n  if (Component.options && Component._Ctor === Component) {\n    return Component;\n  }\n  if (!Component.options) {\n    Component = external_vue_default.a.extend(Component); // fix issue #6\n    Component._Ctor = Component;\n  } else {\n    Component._Ctor = Component;\n    Component.extendOptions = Component.options;\n  }\n  // If no component name defined, set file path as name, (also fixes #5703)\n  if (!Component.options.name && Component.options.__file) {\n    Component.options.name = Component.options.__file;\n  }\n  return Component;\n}\nfunction getMatchedComponents(route, matches = false, prop = 'components') {\n  return Array.prototype.concat.apply([], route.matched.map((m, index) => {\n    return Object.keys(m[prop]).map(key => {\n      matches && matches.push(index);\n      return m[prop][key];\n    });\n  }));\n}\nfunction getMatchedComponentsInstances(route, matches = false) {\n  return getMatchedComponents(route, matches, 'instances');\n}\nfunction flatMapComponents(route, fn) {\n  return Array.prototype.concat.apply([], route.matched.map((m, index) => {\n    return Object.keys(m.components).reduce((promises, key) => {\n      if (m.components[key]) {\n        promises.push(fn(m.components[key], m.instances[key], m, key, index));\n      } else {\n        delete m.components[key];\n      }\n      return promises;\n    }, []);\n  }));\n}\nfunction resolveRouteComponents(route, fn) {\n  return Promise.all(flatMapComponents(route, async (Component, instance, match, key) => {\n    // If component is a function, resolve it\n    if (typeof Component === 'function' && !Component.options) {\n      Component = await Component();\n    }\n    match.components[key] = Component = sanitizeComponent(Component);\n    return typeof fn === 'function' ? fn(Component, instance, match, key) : Component;\n  }));\n}\nasync function getRouteData(route) {\n  if (!route) {\n    return;\n  }\n  // Make sure the components are resolved (code-splitting)\n  await resolveRouteComponents(route);\n  // Send back a copy of route with meta based on Component definition\n  return {\n    ...route,\n    meta: getMatchedComponents(route).map((Component, index) => {\n      return {\n        ...Component.options.meta,\n        ...(route.matched[index] || {}).meta\n      };\n    })\n  };\n}\nasync function setContext(app, context) {\n  // If context not defined, create it\n  if (!app.context) {\n    app.context = {\n      isStatic: true,\n      isDev: false,\n      isHMR: false,\n      app,\n      payload: context.payload,\n      error: context.error,\n      base: app.router.options.base,\n      env: {}\n    };\n    // Only set once\n\n    if (context.ssrContext) {\n      app.context.ssrContext = context.ssrContext;\n    }\n    app.context.redirect = (status, path, query) => {\n      if (!status) {\n        return;\n      }\n      app.context._redirected = true;\n      // if only 1 or 2 arguments: redirect('/') or redirect('/', { foo: 'bar' })\n      let pathType = typeof path;\n      if (typeof status !== 'number' && (pathType === 'undefined' || pathType === 'object')) {\n        query = path || {};\n        path = status;\n        pathType = typeof path;\n        status = 302;\n      }\n      if (pathType === 'object') {\n        path = app.router.resolve(path).route.fullPath;\n      }\n      // \"/absolute/route\", \"./relative/route\" or \"../relative/route\"\n      if (/(^[.]{1,2}\\/)|(^\\/(?!\\/))/.test(path)) {\n        app.context.next({\n          path,\n          query,\n          status\n        });\n      } else {\n        path = Object(dist[\"withQuery\"])(path, query);\n        if (true) {\n          app.context.next({\n            path,\n            status\n          });\n        }\n        if (false) {}\n      }\n    };\n    if (true) {\n      app.context.beforeNuxtRender = fn => context.beforeRenderFns.push(fn);\n    }\n    if (false) {}\n  }\n\n  // Dynamic keys\n  const [currentRouteData, fromRouteData] = await Promise.all([getRouteData(context.route), getRouteData(context.from)]);\n  if (context.route) {\n    app.context.route = currentRouteData;\n  }\n  if (context.from) {\n    app.context.from = fromRouteData;\n  }\n  app.context.next = context.next;\n  app.context._redirected = false;\n  app.context._errored = false;\n  app.context.isHMR = false;\n  app.context.params = app.context.route.params || {};\n  app.context.query = app.context.route.query || {};\n}\nfunction middlewareSeries(promises, appContext) {\n  if (!promises.length || appContext._redirected || appContext._errored) {\n    return Promise.resolve();\n  }\n  return promisify(promises[0], appContext).then(() => {\n    return middlewareSeries(promises.slice(1), appContext);\n  });\n}\nfunction promisify(fn, context) {\n  let promise;\n  if (fn.length === 2) {\n    // fn(context, callback)\n    promise = new Promise(resolve => {\n      fn(context, function (err, data) {\n        if (err) {\n          context.error(err);\n        }\n        data = data || {};\n        resolve(data);\n      });\n    });\n  } else {\n    promise = fn(context);\n  }\n  if (promise && promise instanceof Promise && typeof promise.then === 'function') {\n    return promise;\n  }\n  return Promise.resolve(promise);\n}\n\n// Imported from vue-router\nfunction getLocation(base, mode) {\n  if (mode === 'hash') {\n    return window.location.hash.replace(/^#\\//, '');\n  }\n  base = decodeURI(base).slice(0, -1); // consideration is base is normalized with trailing slash\n  let path = decodeURI(window.location.pathname);\n  if (base && path.startsWith(base)) {\n    path = path.slice(base.length);\n  }\n  const fullPath = (path || '/') + window.location.search + window.location.hash;\n  return Object(dist[\"normalizeURL\"])(fullPath);\n}\n\n// Imported from path-to-regexp\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\nfunction getQueryDiff(toQuery, fromQuery) {\n  const diff = {};\n  const queries = {\n    ...toQuery,\n    ...fromQuery\n  };\n  for (const k in queries) {\n    if (String(toQuery[k]) !== String(fromQuery[k])) {\n      diff[k] = true;\n    }\n  }\n  return diff;\n}\nfunction normalizeError(err) {\n  let message;\n  if (!(err.message || typeof err === 'string')) {\n    try {\n      message = JSON.stringify(err, null, 2);\n    } catch (e) {\n      message = `[${err.constructor.name}]`;\n    }\n  } else {\n    message = err.message || err;\n  }\n  return {\n    ...err,\n    message,\n    statusCode: err.statusCode || err.status || err.response && err.response.status || 500\n  };\n}\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nconst PATH_REGEXP = new RegExp([\n// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)',\n// Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse(str, options) {\n  const tokens = [];\n  let key = 0;\n  let index = 0;\n  let path = '';\n  const defaultDelimiter = options && options.delimiter || '/';\n  let res;\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    const m = res[0];\n    const escaped = res[1];\n    const offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n    const next = str[index];\n    const prefix = res[2];\n    const name = res[3];\n    const capture = res[4];\n    const group = res[5];\n    const modifier = res[6];\n    const asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n    const partial = prefix != null && next != null && next !== prefix;\n    const repeat = modifier === '+' || modifier === '*';\n    const optional = modifier === '?' || modifier === '*';\n    const delimiter = res[2] || defaultDelimiter;\n    const pattern = capture || group;\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter,\n      optional,\n      repeat,\n      partial,\n      asterisk: Boolean(asterisk),\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n  return tokens;\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty(str, slashAllowed) {\n  const re = slashAllowed ? /[?#]/g : /[/?#]/g;\n  return encodeURI(str).replace(re, c => {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk(str) {\n  return encodeURIComponentPretty(str, true);\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1');\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n  // Compile all the tokens into regexps.\n  const matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (let i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));\n    }\n  }\n  return function (obj, opts) {\n    let path = '';\n    const data = obj || {};\n    const options = opts || {};\n    const encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n      const value = data[token.name || 'pathMatch'];\n      let segment;\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n        for (let j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n        continue;\n      }\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n      path += token.prefix + segment;\n    }\n    return path;\n  };\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags(options) {\n  return options && options.sensitive ? '' : 'i';\n}\nfunction addLifecycleHook(vm, hook, fn) {\n  if (!vm.$options[hook]) {\n    vm.$options[hook] = [];\n  }\n  if (!vm.$options[hook].includes(fn)) {\n    vm.$options[hook].push(fn);\n  }\n}\nconst urlJoin = dist[\"joinURL\"];\nconst stripTrailingSlash = dist[\"withoutTrailingSlash\"];\nconst isSamePath = dist[\"isSamePath\"];\nfunction setScrollRestoration(newVal) {\n  try {\n    window.history.scrollRestoration = newVal;\n  } catch (e) {}\n}\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/mixins/fetch.server.js\n\n\nasync function serverPrefetch() {\n  if (!this._fetchOnServer) {\n    return;\n  }\n\n  // Call and await on $fetch\n  try {\n    await this.$options.fetch.call(this);\n  } catch (err) {\n    if (false) {}\n    this.$fetchState.error = normalizeError(err);\n  }\n  this.$fetchState.pending = false;\n\n  // Define an ssrKey for hydration\n  this._fetchKey = this._fetchKey || this.$ssrContext.fetchCounters['']++;\n\n  // Add data-fetch-key on parent element of Component\n  const attrs = this.$vnode.data.attrs = this.$vnode.data.attrs || {};\n  attrs['data-fetch-key'] = this._fetchKey;\n\n  // Add to ssrContext for window.__NUXT__.fetch\n\n  this.$ssrContext.nuxt.fetch[this._fetchKey] = this.$fetchState.error ? {\n    _error: this.$fetchState.error\n  } : purifyData(this._data);\n}\n/* harmony default export */ var fetch_server = ({\n  created() {\n    if (!hasFetch(this)) {\n      return;\n    }\n    if (typeof this.$options.fetchOnServer === 'function') {\n      this._fetchOnServer = this.$options.fetchOnServer.call(this) !== false;\n    } else {\n      this._fetchOnServer = this.$options.fetchOnServer !== false;\n    }\n    const defaultKey = this.$options._scopeId || this.$options.name || '';\n    const getCounter = createGetCounter(this.$ssrContext.fetchCounters, defaultKey);\n    if (typeof this.$options.fetchKey === 'function') {\n      this._fetchKey = this.$options.fetchKey.call(this, getCounter);\n    } else {\n      const key = 'string' === typeof this.$options.fetchKey ? this.$options.fetchKey : defaultKey;\n      this._fetchKey = key ? key + ':' + getCounter(key) : String(getCounter(key));\n    }\n\n    // Added for remove vue undefined warning while ssr\n    this.$fetch = () => {}; // issue #8043\n    external_vue_default.a.util.defineReactive(this, '$fetchState', {\n      pending: true,\n      error: null,\n      timestamp: Date.now()\n    });\n    addLifecycleHook(this, 'serverPrefetch', serverPrefetch);\n  }\n});\n// EXTERNAL MODULE: external \"vue-meta\"\nvar external_vue_meta_ = __webpack_require__(14);\nvar external_vue_meta_default = /*#__PURE__*/__webpack_require__.n(external_vue_meta_);\n\n// EXTERNAL MODULE: external \"vue-client-only\"\nvar external_vue_client_only_ = __webpack_require__(7);\nvar external_vue_client_only_default = /*#__PURE__*/__webpack_require__.n(external_vue_client_only_);\n\n// EXTERNAL MODULE: external \"vue-no-ssr\"\nvar external_vue_no_ssr_ = __webpack_require__(4);\nvar external_vue_no_ssr_default = /*#__PURE__*/__webpack_require__.n(external_vue_no_ssr_);\n\n// EXTERNAL MODULE: external \"vue-router\"\nvar external_vue_router_ = __webpack_require__(8);\nvar external_vue_router_default = /*#__PURE__*/__webpack_require__.n(external_vue_router_);\n\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/router.scrollBehavior.js\n\nif (false) {}\nfunction shouldScrollToTop(route) {\n  const Pages = getMatchedComponents(route);\n  if (Pages.length === 1) {\n    const {\n      options = {}\n    } = Pages[0];\n    return options.scrollToTop !== false;\n  }\n  return Pages.some(({\n    options\n  }) => options && options.scrollToTop);\n}\n/* harmony default export */ var router_scrollBehavior = (function (to, from, savedPosition) {\n  // If the returned position is falsy or an empty object, will retain current scroll position\n  let position = false;\n  const isRouteChanged = to !== from;\n\n  // savedPosition is only available for popstate navigations (back button)\n  if (savedPosition) {\n    position = savedPosition;\n  } else if (isRouteChanged && shouldScrollToTop(to)) {\n    position = {\n      x: 0,\n      y: 0\n    };\n  }\n  const nuxt = window.$nuxt;\n  if (\n  // Initial load (vuejs/vue-router#3199)\n  !isRouteChanged ||\n  // Route hash changes\n  to.path === from.path && to.hash !== from.hash) {\n    nuxt.$nextTick(() => nuxt.$emit('triggerScroll'));\n  }\n  return new Promise(resolve => {\n    // wait for the out transition to complete (if necessary)\n    nuxt.$once('triggerScroll', () => {\n      // coords will be used if no selector is provided,\n      // or if the selector didn't match any element.\n      if (to.hash) {\n        let hash = to.hash;\n        // CSS.escape() is not supported with IE and Edge.\n        if (typeof window.CSS !== 'undefined' && typeof window.CSS.escape !== 'undefined') {\n          hash = '#' + window.CSS.escape(hash.substr(1));\n        }\n        try {\n          if (document.querySelector(hash)) {\n            // scroll to anchor by returning the selector\n            position = {\n              selector: hash\n            };\n          }\n        } catch (e) {\n          console.warn('Failed to save scroll position. Please add CSS.escape() polyfill (https://github.com/mathiasbynens/CSS.escape).');\n        }\n      }\n      resolve(position);\n    });\n  });\n});\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/router.js\n\n\n\n\n\nconst _75f4a298 = () => interopDefault(__webpack_require__.e(/* import() | pages/works/brg */ 16).then(__webpack_require__.bind(null, 102)));\nconst _5162f956 = () => interopDefault(__webpack_require__.e(/* import() | pages/works/heating-pad */ 17).then(__webpack_require__.bind(null, 103)));\nconst _32feed1a = () => interopDefault(__webpack_require__.e(/* import() | pages/works/workPage */ 18).then(__webpack_require__.bind(null, 104)));\nconst _9007b308 = () => interopDefault(__webpack_require__.e(/* import() | pages/index */ 15).then(__webpack_require__.bind(null, 105)));\n\nconst emptyFn = () => {};\nexternal_vue_default.a.use(external_vue_router_default.a);\nconst routerOptions = {\n  mode: 'history',\n  base: '/home/',\n  linkActiveClass: 'active',\n  linkExactActiveClass: 'nuxt-link-exact-active',\n  scrollBehavior: router_scrollBehavior,\n  routes: [{\n    path: \"/works/brg\",\n    component: _75f4a298,\n    name: \"works-brg\"\n  }, {\n    path: \"/works/heating-pad\",\n    component: _5162f956,\n    name: \"works-heating-pad\"\n  }, {\n    path: \"/works/workPage\",\n    component: _32feed1a,\n    name: \"works-workPage\"\n  }, {\n    path: \"/\",\n    component: _9007b308,\n    name: \"index\"\n  }],\n  fallback: false\n};\nfunction createRouter(ssrContext, config) {\n  const base = config.app && config.app.basePath || routerOptions.base;\n  const router = new external_vue_router_default.a({\n    ...routerOptions,\n    base\n  });\n\n  // TODO: remove in Nuxt 3\n  const originalPush = router.push;\n  router.push = function push(location, onComplete = emptyFn, onAbort) {\n    return originalPush.call(this, location, onComplete, onAbort);\n  };\n  const resolve = router.resolve.bind(router);\n  router.resolve = (to, current, append) => {\n    if (typeof to === 'string') {\n      to = Object(dist[\"normalizeURL\"])(to);\n    }\n    return resolve(to, current, append);\n  };\n  return router;\n}\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-child.js\n/* harmony default export */ var nuxt_child = ({\n  name: 'NuxtChild',\n  functional: true,\n  props: {\n    nuxtChildKey: {\n      type: String,\n      default: ''\n    },\n    keepAlive: Boolean,\n    keepAliveProps: {\n      type: Object,\n      default: undefined\n    }\n  },\n  render(_, {\n    parent,\n    data,\n    props\n  }) {\n    const h = parent.$createElement;\n    data.nuxtChild = true;\n    const _parent = parent;\n    const transitions = parent.$nuxt.nuxt.transitions;\n    const defaultTransition = parent.$nuxt.nuxt.defaultTransition;\n    let depth = 0;\n    while (parent) {\n      if (parent.$vnode && parent.$vnode.data.nuxtChild) {\n        depth++;\n      }\n      parent = parent.$parent;\n    }\n    data.nuxtChildDepth = depth;\n    const transition = transitions[depth] || defaultTransition;\n    const transitionProps = {};\n    transitionsKeys.forEach(key => {\n      if (typeof transition[key] !== 'undefined') {\n        transitionProps[key] = transition[key];\n      }\n    });\n    const listeners = {};\n    listenersKeys.forEach(key => {\n      if (typeof transition[key] === 'function') {\n        listeners[key] = transition[key].bind(_parent);\n      }\n    });\n    if (false) {}\n\n    // make sure that leave is called asynchronous (fix #5703)\n    if (transition.css === false) {\n      const leave = listeners.leave;\n\n      // only add leave listener when user didnt provide one\n      // or when it misses the done argument\n      if (!leave || leave.length < 2) {\n        listeners.leave = (el, done) => {\n          if (leave) {\n            leave.call(_parent, el);\n          }\n          _parent.$nextTick(done);\n        };\n      }\n    }\n    let routerView = h('routerView', data);\n    if (props.keepAlive) {\n      routerView = h('keep-alive', {\n        props: props.keepAliveProps\n      }, [routerView]);\n    }\n    return h('transition', {\n      props: transitionProps,\n      on: listeners\n    }, [routerView]);\n  }\n});\nconst transitionsKeys = ['name', 'mode', 'appear', 'css', 'type', 'duration', 'enterClass', 'leaveClass', 'appearClass', 'enterActiveClass', 'enterActiveClass', 'leaveActiveClass', 'appearActiveClass', 'enterToClass', 'leaveToClass', 'appearToClass'];\nconst listenersKeys = ['beforeEnter', 'enter', 'afterEnter', 'enterCancelled', 'beforeLeave', 'leave', 'afterLeave', 'leaveCancelled', 'beforeAppear', 'appear', 'afterAppear', 'appearCancelled'];\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=template&id=608a1420&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"__nuxt-error-page\"},[_vm._ssrNode(\"<div class=\\\"error\\\">\",\"</div>\",[_vm._ssrNode(\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"90\\\" height=\\\"90\\\" fill=\\\"#DBE1EC\\\" viewBox=\\\"0 0 48 48\\\"><path d=\\\"M22 30h4v4h-4zm0-16h4v12h-4zm1.99-10C12.94 4 4 12.95 4 24s8.94 20 19.99 20S44 35.05 44 24 35.04 4 23.99 4zM24 40c-8.84 0-16-7.16-16-16S15.16 8 24 8s16 7.16 16 16-7.16 16-16 16z\\\"></path></svg> <div class=\\\"title\\\">\"+_vm._ssrEscape(_vm._s(_vm.message))+\"</div> \"),(_vm.statusCode === 404)?_vm._ssrNode(\"<p class=\\\"description\\\">\",\"</p>\",[(typeof _vm.$route === 'undefined')?_vm._ssrNode(\"<a href=\\\"/\\\" class=\\\"error-link\\\">\",\"</a>\"):_c('NuxtLink',{staticClass:\"error-link\",attrs:{\"to\":\"/\"}},[_vm._v(\"Back to the home page\")])],1):_vm._e(),_vm._ssrNode(\" <div class=\\\"logo\\\"><a href=\\\"https://nuxtjs.org\\\" target=\\\"_blank\\\" rel=\\\"noopener\\\">Nuxt</a></div>\")],2)])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=template&id=608a1420&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--2-0!./node_modules/babel-loader/lib??ref--2-1!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var nuxt_errorvue_type_script_lang_js_ = ({\n  name: 'NuxtError',\n  props: {\n    error: {\n      type: Object,\n      default: null\n    }\n  },\n  computed: {\n    statusCode() {\n      return this.error && this.error.statusCode || 500;\n    },\n    message() {\n      return this.error.message || 'Error';\n    }\n  },\n  head() {\n    return {\n      title: this.message,\n      meta: [{\n        name: 'viewport',\n        content: 'width=device-width,initial-scale=1.0,minimum-scale=1.0'\n      }]\n    };\n  }\n});\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_nuxt_errorvue_type_script_lang_js_ = (nuxt_errorvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-error.vue\n\n\n\nfunction injectStyles (context) {\n  \n  var style0 = __webpack_require__(18)\nif (style0.__inject__) style0.__inject__(context)\n\n}\n\n/* normalize component */\n\nvar nuxt_error_component = Object(componentNormalizer[\"a\" /* default */])(\n  components_nuxt_errorvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  injectStyles,\n  null,\n  \"f5767116\"\n  \n)\n\n/* harmony default export */ var nuxt_error = (nuxt_error_component.exports);\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt.js\n\n\n\n\n/* harmony default export */ var components_nuxt = ({\n  name: 'Nuxt',\n  components: {\n    NuxtChild: nuxt_child,\n    NuxtError: nuxt_error\n  },\n  props: {\n    nuxtChildKey: {\n      type: String,\n      default: undefined\n    },\n    keepAlive: Boolean,\n    keepAliveProps: {\n      type: Object,\n      default: undefined\n    },\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  errorCaptured(error) {\n    // if we receive and error while showing the NuxtError component\n    // capture the error and force an immediate update so we re-render\n    // without the NuxtError component\n    if (this.displayingNuxtError) {\n      this.errorFromNuxtError = error;\n      this.$forceUpdate();\n    }\n  },\n  computed: {\n    routerViewKey() {\n      // If nuxtChildKey prop is given or current route has children\n      if (typeof this.nuxtChildKey !== 'undefined' || this.$route.matched.length > 1) {\n        return this.nuxtChildKey || compile(this.$route.matched[0].path)(this.$route.params);\n      }\n      const [matchedRoute] = this.$route.matched;\n      if (!matchedRoute) {\n        return this.$route.path;\n      }\n      const Component = matchedRoute.components.default;\n      if (Component && Component.options) {\n        const {\n          options\n        } = Component;\n        if (options.key) {\n          return typeof options.key === 'function' ? options.key(this.$route) : options.key;\n        }\n      }\n      const strict = /\\/$/.test(matchedRoute.path);\n      return strict ? this.$route.path : this.$route.path.replace(/\\/$/, '');\n    }\n  },\n  beforeCreate() {\n    external_vue_default.a.util.defineReactive(this, 'nuxt', this.$root.$options.nuxt);\n  },\n  render(h) {\n    // if there is no error\n    if (!this.nuxt.err) {\n      // Directly return nuxt child\n      return h('NuxtChild', {\n        key: this.routerViewKey,\n        props: this.$props\n      });\n    }\n\n    // if an error occurred within NuxtError show a simple\n    // error message instead to prevent looping\n    if (this.errorFromNuxtError) {\n      this.$nextTick(() => this.errorFromNuxtError = false);\n      return h('div', {}, [h('h2', 'An error occurred while showing the error page'), h('p', 'Unfortunately an error occurred and while showing the error page another error occurred'), h('p', `Error details: ${this.errorFromNuxtError.toString()}`), h('nuxt-link', {\n        props: {\n          to: '/'\n        }\n      }, 'Go back to home')]);\n    }\n\n    // track if we are showing the NuxtError component\n    this.displayingNuxtError = true;\n    this.$nextTick(() => this.displayingNuxtError = false);\n    return h(nuxt_error, {\n      props: {\n        error: this.nuxt.err\n      }\n    });\n  }\n});\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--2-0!./node_modules/babel-loader/lib??ref--2-1!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/.cache/nuxt/components/nuxt-loading.vue?vue&type=script&lang=js&\n/* harmony default export */ var nuxt_loadingvue_type_script_lang_js_ = ({\n  name: 'NuxtLoading',\n  data() {\n    return {\n      percent: 0,\n      show: false,\n      canSucceed: true,\n      reversed: false,\n      skipTimerCount: 0,\n      rtl: false,\n      throttle: 200,\n      duration: 5000,\n      continuous: false\n    };\n  },\n  computed: {\n    left() {\n      if (!this.continuous && !this.rtl) {\n        return false;\n      }\n      return this.rtl ? this.reversed ? '0px' : 'auto' : !this.reversed ? '0px' : 'auto';\n    }\n  },\n  beforeDestroy() {\n    this.clear();\n  },\n  methods: {\n    clear() {\n      clearInterval(this._timer);\n      clearTimeout(this._throttle);\n      this._timer = null;\n    },\n    start() {\n      this.clear();\n      this.percent = 0;\n      this.reversed = false;\n      this.skipTimerCount = 0;\n      this.canSucceed = true;\n      if (this.throttle) {\n        this._throttle = setTimeout(() => this.startTimer(), this.throttle);\n      } else {\n        this.startTimer();\n      }\n      return this;\n    },\n    set(num) {\n      this.show = true;\n      this.canSucceed = true;\n      this.percent = Math.min(100, Math.max(0, Math.floor(num)));\n      return this;\n    },\n    get() {\n      return this.percent;\n    },\n    increase(num) {\n      this.percent = Math.min(100, Math.floor(this.percent + num));\n      return this;\n    },\n    decrease(num) {\n      this.percent = Math.max(0, Math.floor(this.percent - num));\n      return this;\n    },\n    pause() {\n      clearInterval(this._timer);\n      return this;\n    },\n    resume() {\n      this.startTimer();\n      return this;\n    },\n    finish() {\n      this.percent = this.reversed ? 0 : 100;\n      this.hide();\n      return this;\n    },\n    hide() {\n      this.clear();\n      setTimeout(() => {\n        this.show = false;\n        this.$nextTick(() => {\n          this.percent = 0;\n          this.reversed = false;\n        });\n      }, 500);\n      return this;\n    },\n    fail(error) {\n      this.canSucceed = false;\n      return this;\n    },\n    startTimer() {\n      if (!this.show) {\n        this.show = true;\n      }\n      if (typeof this._cut === 'undefined') {\n        this._cut = 10000 / Math.floor(this.duration);\n      }\n      this._timer = setInterval(() => {\n        /**\n         * When reversing direction skip one timers\n         * so 0, 100 are displayed for two iterations\n         * also disable css width transitioning\n         * which otherwise interferes and shows\n         * a jojo effect\n         */\n        if (this.skipTimerCount > 0) {\n          this.skipTimerCount--;\n          return;\n        }\n        if (this.reversed) {\n          this.decrease(this._cut);\n        } else {\n          this.increase(this._cut);\n        }\n        if (this.continuous) {\n          if (this.percent >= 100) {\n            this.skipTimerCount = 1;\n            this.reversed = !this.reversed;\n          } else if (this.percent <= 0) {\n            this.skipTimerCount = 1;\n            this.reversed = !this.reversed;\n          }\n        }\n      }, 100);\n    }\n  },\n  render(h) {\n    let el = h(false);\n    if (this.show) {\n      el = h('div', {\n        staticClass: 'nuxt-progress',\n        class: {\n          'nuxt-progress-notransition': this.skipTimerCount > 0,\n          'nuxt-progress-failed': !this.canSucceed\n        },\n        style: {\n          width: this.percent + '%',\n          left: this.left\n        }\n      });\n    }\n    return el;\n  }\n});\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-loading.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_nuxt_loadingvue_type_script_lang_js_ = (nuxt_loadingvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-loading.vue\nvar nuxt_loading_render, nuxt_loading_staticRenderFns\n\n\nfunction nuxt_loading_injectStyles (context) {\n  \n  var style0 = __webpack_require__(19)\nif (style0.__inject__) style0.__inject__(context)\n\n}\n\n/* normalize component */\n\nvar nuxt_loading_component = Object(componentNormalizer[\"a\" /* default */])(\n  components_nuxt_loadingvue_type_script_lang_js_,\n  nuxt_loading_render,\n  nuxt_loading_staticRenderFns,\n  false,\n  nuxt_loading_injectStyles,\n  null,\n  \"84f0892e\"\n  \n)\n\n/* harmony default export */ var nuxt_loading = (nuxt_loading_component.exports);\n// EXTERNAL MODULE: ./node_modules/locomotive-scroll/dist/locomotive-scroll.css\nvar locomotive_scroll = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/normalize.css/normalize.css\nvar normalize = __webpack_require__(21);\n\n// EXTERNAL MODULE: ./css/global.css\nvar css_global = __webpack_require__(22);\n\n// EXTERNAL MODULE: ./css/utils.css\nvar utils = __webpack_require__(23);\n\n// EXTERNAL MODULE: ./node_modules/prismjs/themes/prism.css\nvar prism = __webpack_require__(24);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./layouts/default.vue?vue&type=template&id=60470949&\nvar defaultvue_type_template_id_60470949_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_vm._ssrNode(\"<div role=\\\"presentation\\\" class=\\\"scroller\\\">\",\"</div>\",[_c('Nuxt')],1),_vm._ssrNode(\" \"),_c('V-Pointer'),_vm._ssrNode(\" \"),_c('V-Loader')],2)}\nvar defaultvue_type_template_id_60470949_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./layouts/default.vue?vue&type=template&id=60470949&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--2-0!./node_modules/babel-loader/lib??ref--2-1!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./layouts/default.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var defaultvue_type_script_lang_js_ = ({\n  name: 'DefaultLayout',\n  mounted() {\n    this.clear();\n    this.setViewHeight();\n    window.addEventListener('resize', this.setViewHeight);\n  },\n  methods: {\n    setViewHeight() {\n      const vh = window.innerHeight * 0.01;\n      document.documentElement.style.setProperty('--vh', `${vh}px`);\n    },\n    clear() {\n      console.clear();\n    }\n  }\n});\n// CONCATENATED MODULE: ./layouts/default.vue?vue&type=script&lang=js&\n /* harmony default export */ var layouts_defaultvue_type_script_lang_js_ = (defaultvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./layouts/default.vue\n\n\n\nfunction default_injectStyles (context) {\n  \n  \n}\n\n/* normalize component */\n\nvar default_component = Object(componentNormalizer[\"a\" /* default */])(\n  layouts_defaultvue_type_script_lang_js_,\n  defaultvue_type_template_id_60470949_render,\n  defaultvue_type_template_id_60470949_staticRenderFns,\n  false,\n  default_injectStyles,\n  null,\n  \"eb59acd2\"\n  \n)\n\n/* harmony default export */ var layouts_default = (default_component.exports);\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/App.js\n\n\n\n\n\n\n\n\n\n\n\nconst layouts = {\n  \"_default\": sanitizeComponent(layouts_default)\n};\n/* harmony default export */ var App = ({\n  render(h, props) {\n    const loadingEl = h('NuxtLoading', {\n      ref: 'loading'\n    });\n    const layoutEl = h(this.layout || 'nuxt');\n    const templateEl = h('div', {\n      domProps: {\n        id: '__layout'\n      },\n      key: this.layoutName\n    }, [layoutEl]);\n    const transitionEl = h('transition', {\n      props: {\n        name: 'layout',\n        mode: 'out-in'\n      },\n      on: {\n        beforeEnter(el) {\n          // Ensure to trigger scroll event after calling scrollBehavior\n          window.$nuxt.$nextTick(() => {\n            window.$nuxt.$emit('triggerScroll');\n          });\n        }\n      }\n    }, [templateEl]);\n    return h('div', {\n      domProps: {\n        id: '__nuxt'\n      }\n    }, [loadingEl, transitionEl]);\n  },\n  data: () => ({\n    isOnline: true,\n    layout: null,\n    layoutName: '',\n    nbFetching: 0\n  }),\n  beforeCreate() {\n    external_vue_default.a.util.defineReactive(this, 'nuxt', this.$options.nuxt);\n  },\n  created() {\n    // Add this.$nuxt in child instances\n    this.$root.$options.$nuxt = this;\n    if (false) {}\n    // Add $nuxt.error()\n    this.error = this.nuxt.error;\n    // Add $nuxt.context\n    this.context = this.$options.context;\n  },\n  async mounted() {\n    this.$loading = this.$refs.loading;\n    if (this.isPreview) {\n      if (this.$store && this.$store._actions.nuxtServerInit) {\n        this.$loading.start();\n        await this.$store.dispatch('nuxtServerInit', this.context);\n      }\n      await this.refresh();\n      this.$loading.finish();\n    }\n  },\n  watch: {\n    'nuxt.err': 'errorChanged'\n  },\n  computed: {\n    isOffline() {\n      return !this.isOnline;\n    },\n    isFetching() {\n      return this.nbFetching > 0;\n    },\n    isPreview() {\n      return Boolean(this.$options.previewData);\n    }\n  },\n  methods: {\n    refreshOnlineStatus() {\n      if (false) {}\n    },\n    async refresh() {\n      const pages = getMatchedComponentsInstances(this.$route);\n      if (!pages.length) {\n        return;\n      }\n      this.$loading.start();\n      const promises = pages.map(page => {\n        const p = [];\n\n        // Old fetch\n        if (page.$options.fetch && page.$options.fetch.length) {\n          p.push(promisify(page.$options.fetch, this.context));\n        }\n        if (page.$fetch) {\n          p.push(page.$fetch());\n        } else {\n          // Get all component instance to call $fetch\n          for (const component of getChildrenComponentInstancesUsingFetch(page.$vnode.componentInstance)) {\n            p.push(component.$fetch());\n          }\n        }\n        if (page.$options.asyncData) {\n          p.push(promisify(page.$options.asyncData, this.context).then(newData => {\n            for (const key in newData) {\n              external_vue_default.a.set(page.$data, key, newData[key]);\n            }\n          }));\n        }\n        return Promise.all(p);\n      });\n      try {\n        await Promise.all(promises);\n      } catch (error) {\n        this.$loading.fail(error);\n        globalHandleError(error);\n        this.error(error);\n      }\n      this.$loading.finish();\n    },\n    errorChanged() {\n      if (this.nuxt.err) {\n        if (this.$loading) {\n          if (this.$loading.fail) {\n            this.$loading.fail(this.nuxt.err);\n          }\n          if (this.$loading.finish) {\n            this.$loading.finish();\n          }\n        }\n        let errorLayout = (nuxt_error.options || nuxt_error).layout;\n        if (typeof errorLayout === 'function') {\n          errorLayout = errorLayout(this.context);\n        }\n        this.setLayout(errorLayout);\n      }\n    },\n    setLayout(layout) {\n      if (!layout || !layouts['_' + layout]) {\n        layout = 'default';\n      }\n      this.layoutName = layout;\n      this.layout = layouts['_' + layout];\n      return this.layout;\n    },\n    loadLayout(layout) {\n      if (!layout || !layouts['_' + layout]) {\n        layout = 'default';\n      }\n      return Promise.resolve(layouts['_' + layout]);\n    },\n    getRouterBase() {\n      return Object(dist[\"withoutTrailingSlash\"])(this.$router.options.base);\n    },\n    getRoutePath(route = '/') {\n      const base = this.getRouterBase();\n      return Object(dist[\"withoutTrailingSlash\"])(Object(dist[\"withoutBase\"])(Object(dist[\"parsePath\"])(route).pathname, base));\n    },\n    getStaticAssetsPath(route = '/') {\n      const {\n        staticAssetsBase\n      } = window.__NUXT__;\n      return urlJoin(staticAssetsBase, this.getRoutePath(route));\n    },\n    async fetchStaticManifest() {\n      return window.__NUXT_IMPORT__('manifest.js', Object(dist[\"normalizeURL\"])(urlJoin(this.getStaticAssetsPath(), 'manifest.js')));\n    },\n    setPagePayload(payload) {\n      this._pagePayload = payload;\n      this._fetchCounters = {};\n    },\n    async fetchPayload(route, prefetch) {\n      const path = Object(dist[\"decode\"])(this.getRoutePath(route));\n      const manifest = await this.fetchStaticManifest();\n      if (!manifest.routes.includes(path)) {\n        if (!prefetch) {\n          this.setPagePayload(false);\n        }\n        throw new Error(`Route ${path} is not pre-rendered`);\n      }\n      const src = urlJoin(this.getStaticAssetsPath(route), 'payload.js');\n      try {\n        const payload = await window.__NUXT_IMPORT__(path, Object(dist[\"normalizeURL\"])(src));\n        if (!prefetch) {\n          this.setPagePayload(payload);\n        }\n        return payload;\n      } catch (err) {\n        if (!prefetch) {\n          this.setPagePayload(false);\n        }\n        throw err;\n      }\n    }\n  },\n  components: {\n    NuxtLoading: nuxt_loading\n  }\n});\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/index.js\nconst VAbout = () => __webpack_require__.e(/* import() | components/v-about */ 1).then(__webpack_require__.bind(null, 106)).then(c => wrapFunctional(c.default || c));\nconst VContact = () => __webpack_require__.e(/* import() | components/v-contact */ 2).then(__webpack_require__.bind(null, 107)).then(c => wrapFunctional(c.default || c));\nconst VFooterSocialLink = () => __webpack_require__.e(/* import() | components/v-footer-social-link */ 4).then(__webpack_require__.bind(null, 108)).then(c => wrapFunctional(c.default || c));\nconst VFooter = () => __webpack_require__.e(/* import() | components/v-footer */ 3).then(__webpack_require__.bind(null, 109)).then(c => wrapFunctional(c.default || c));\nconst VH2 = () => __webpack_require__.e(/* import() | components/v-h2 */ 5).then(__webpack_require__.bind(null, 110)).then(c => wrapFunctional(c.default || c));\nconst VHeaderBackground = () => __webpack_require__.e(/* import() | components/v-header-background */ 7).then(__webpack_require__.bind(null, 101)).then(c => wrapFunctional(c.default || c));\nconst VHeader = () => __webpack_require__.e(/* import() | components/v-header */ 6).then(__webpack_require__.bind(null, 111)).then(c => wrapFunctional(c.default || c));\nconst VLoader = () => __webpack_require__.e(/* import() | components/v-loader */ 8).then(__webpack_require__.bind(null, 112)).then(c => wrapFunctional(c.default || c));\nconst VMenu = () => __webpack_require__.e(/* import() | components/v-menu */ 9).then(__webpack_require__.bind(null, 113)).then(c => wrapFunctional(c.default || c));\nconst VNavbar = () => __webpack_require__.e(/* import() | components/v-navbar */ 10).then(__webpack_require__.bind(null, 114)).then(c => wrapFunctional(c.default || c));\nconst VPointer = () => __webpack_require__.e(/* import() | components/v-pointer */ 11).then(__webpack_require__.bind(null, 115)).then(c => wrapFunctional(c.default || c));\nconst VScrollDown = () => __webpack_require__.e(/* import() | components/v-scroll-down */ 12).then(__webpack_require__.bind(null, 116)).then(c => wrapFunctional(c.default || c));\nconst VWorkItem = () => __webpack_require__.e(/* import() | components/v-work-item */ 14).then(__webpack_require__.bind(null, 117)).then(c => wrapFunctional(c.default || c));\nconst VWork = () => __webpack_require__.e(/* import() | components/v-work */ 13).then(__webpack_require__.bind(null, 118)).then(c => wrapFunctional(c.default || c));\n\n// nuxt/nuxt.js#8607\nfunction wrapFunctional(options) {\n  if (!options || !options.functional) {\n    return options;\n  }\n  const propKeys = Array.isArray(options.props) ? options.props : Object.keys(options.props || {});\n  return {\n    render(h) {\n      const attrs = {};\n      const props = {};\n      for (const key in this.$attrs) {\n        if (propKeys.includes(key)) {\n          props[key] = this.$attrs[key];\n        } else {\n          attrs[key] = this.$attrs[key];\n        }\n      }\n      return h(options, {\n        on: this.$listeners,\n        attrs,\n        props,\n        scopedSlots: this.$scopedSlots\n      }, this.$slots.default);\n    }\n  };\n}\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/plugin.js\n\n\nfor (const name in components_namespaceObject) {\n  external_vue_default.a.component(name, components_namespaceObject[name]);\n  external_vue_default.a.component('Lazy' + name, components_namespaceObject[name]);\n}\n// EXTERNAL MODULE: ./node_modules/.cache/nuxt/empty.js\nvar nuxt_empty = __webpack_require__(6);\n\n// EXTERNAL MODULE: external \"property-information\"\nvar external_property_information_ = __webpack_require__(9);\nvar external_property_information_default = /*#__PURE__*/__webpack_require__.n(external_property_information_);\n\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/content/nuxt-content.js\n\nconst rootKeys = ['class-name', 'class', 'className', 'style'];\nconst rxOn = /^@|^v-on:/;\nconst rxBind = /^:|^v-bind:/;\nconst rxModel = /^v-model/;\nconst nativeInputs = ['select', 'textarea', 'input'];\nfunction evalInContext(code, context) {\n  return new Function(\"with(this) { return (\" + code + \") }\").call(context);\n}\nfunction propsToData(node, doc) {\n  const {\n    tag,\n    props\n  } = node;\n  return Object.keys(props).reduce(function (data, key) {\n    const k = key.replace(/.*:/, '');\n    let obj = rootKeys.includes(k) ? data : data.attrs;\n    const value = props[key];\n    const {\n      attribute\n    } = external_property_information_default.a.find(external_property_information_default.a.html, key);\n    const native = nativeInputs.includes(tag);\n    if (rxModel.test(key) && value in doc && !native) {\n      const mods = key.replace(rxModel, '').split('.').filter(d => d).reduce((d, k) => (d[k] = true, d), {});\n\n      // As of yet we don't resolve custom v-model field/event names from components\n      const field = 'value';\n      const event = mods.lazy ? 'change' : 'input';\n      const processor = mods.number ? d => +d : mods.trim ? d => d.trim() : d => d;\n      obj[field] = evalInContext(value, doc);\n      data.on = data.on || {};\n      data.on[event] = e => doc[value] = processor(e);\n    } else if (key === 'v-bind') {\n      const val = value in doc ? doc[value] : evalInContext(value, doc);\n      obj = Object.assign(obj, val);\n    } else if (rxOn.test(key)) {\n      key = key.replace(rxOn, '');\n      data.on = data.on || {};\n      data.on[key] = evalInContext(value, doc);\n    } else if (rxBind.test(key)) {\n      key = key.replace(rxBind, '');\n      obj[key] = value in doc ? doc[value] : evalInContext(value, doc);\n    } else if (Array.isArray(value)) {\n      obj[attribute] = value.join(' ');\n    } else {\n      obj[attribute] = value;\n    }\n    return data;\n  }, {\n    attrs: {}\n  });\n}\n\n/**\n * Create the scoped slots from `node` template children. Templates for default\n * slots are processed as regular children in `processNode`.\n */\nfunction slotsToData(node, h, doc) {\n  const data = {};\n  const children = node.children || [];\n  children.forEach(child => {\n    // Regular children and default templates are processed inside `processNode`.\n    if (!isTemplate(child) || isDefaultTemplate(child)) {\n      return;\n    }\n\n    // Non-default templates are converted into slots.\n    data.scopedSlots = data.scopedSlots || {};\n    const template = child;\n    const name = getSlotName(template);\n    const vDomTree = template.content.map(tmplNode => processNode(tmplNode, h, doc));\n    data.scopedSlots[name] = function () {\n      return vDomTree;\n    };\n  });\n  return data;\n}\nfunction processNode(node, h, doc) {\n  /**\n   * Return raw value as it is\n   */\n  if (node.type === 'text') {\n    return node.value;\n  }\n  const slotData = slotsToData(node || {}, h, doc);\n  const propData = propsToData(node || {}, doc);\n  const data = Object.assign({}, slotData, propData);\n\n  /**\n   * Process child nodes, flat-mapping templates pointing to default slots.\n   */\n  const children = [];\n  for (const child of node.children) {\n    // Template nodes pointing to non-default slots are processed inside `slotsToData`.\n    if (isTemplate(child) && !isDefaultTemplate(child)) {\n      continue;\n    }\n    const processQueue = isDefaultTemplate(child) ? child.content : [child];\n    children.push(...processQueue.map(node => processNode(node, h, doc)));\n  }\n  return h(node.tag, data, children);\n}\nconst DEFAULT_SLOT = 'default';\nfunction isDefaultTemplate(node) {\n  return isTemplate(node) && getSlotName(node) === DEFAULT_SLOT;\n}\nfunction isTemplate(node) {\n  return node.tag === 'template';\n}\nfunction getSlotName(node) {\n  let name = '';\n  for (const propName of Object.keys(node.props)) {\n    if (!propName.startsWith('#') && !propName.startsWith('v-slot:')) {\n      continue;\n    }\n    name = propName.split(/[:#]/, 2)[1];\n    break;\n  }\n  return name || DEFAULT_SLOT;\n}\n/* harmony default export */ var nuxt_content = ({\n  name: 'NuxtContent',\n  functional: true,\n  props: {\n    document: {\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'div'\n    }\n  },\n  render(h, {\n    data,\n    props\n  }) {\n    const {\n      document,\n      tag\n    } = props;\n    const {\n      body\n    } = document || {};\n    if (!body || !body.children || !Array.isArray(body.children)) {\n      return;\n    }\n    let classes = [];\n    if (Array.isArray(data.class)) {\n      classes = data.class;\n    } else if (typeof data.class === 'object') {\n      const keys = Object.keys(data.class);\n      classes = keys.filter(key => data.class[key]);\n    } else {\n      classes = [data.class];\n    }\n    data.class = classes.concat('nuxt-content');\n    data.props = Object.assign({\n      ...body.props\n    }, data.props);\n    return h(tag, data, body.children.map(child => processNode(child, h, document)));\n  }\n});\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/content/plugin.server.js\n\n\nexternal_vue_default.a.component(nuxt_content.name, nuxt_content);\n/* harmony default export */ var plugin_server = ((ctx, inject) => {\n  const $content = ctx.ssrContext.$content;\n  inject('content', $content);\n  ctx.$content = $content;\n});\n// EXTERNAL MODULE: ./node_modules/@nuxt/image/node_modules/defu/dist/defu.cjs\nvar defu = __webpack_require__(10);\nvar defu_default = /*#__PURE__*/__webpack_require__.n(defu);\n\n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/utils/meta.js\nasync function imageMeta(ctx, url) {\n  const cache = getCache(ctx);\n  const cacheKey = \"image:meta:\" + url;\n  if (cache.has(cacheKey)) {\n    return cache.get(cacheKey);\n  }\n  const meta = await _imageMeta(url).catch(err => {\n    console.error(\"Failed to get image meta for \" + url, err + \"\");\n    return {\n      width: 0,\n      height: 0,\n      ratio: 0\n    };\n  });\n  cache.set(cacheKey, meta);\n  return meta;\n}\nasync function _imageMeta(url) {\n  if (true) {\n    const imageMeta2 = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(null, 61, 7)).then(r => r.default || r);\n    const data = await fetch(url).then(res => res.buffer());\n    const metadata = imageMeta2(data);\n    if (!metadata) {\n      throw new Error(`No metadata could be extracted from the image \\`${url}\\`.`);\n    }\n    const {\n      width,\n      height\n    } = metadata;\n    const meta = {\n      width,\n      height,\n      ratio: width && height ? width / height : void 0\n    };\n    return meta;\n  }\n  if (typeof Image === \"undefined\") {\n    throw new TypeError(\"Image not supported\");\n  }\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => {\n      const meta = {\n        width: img.width,\n        height: img.height,\n        ratio: img.width / img.height\n      };\n      resolve(meta);\n    };\n    img.onerror = err => reject(err);\n    img.src = url;\n  });\n}\nfunction getCache(ctx) {\n  if (!ctx.nuxtContext.cache) {\n    if (ctx.nuxtContext.ssrContext && ctx.nuxtContext.ssrContext.cache) {\n      ctx.nuxtContext.cache = ctx.nuxtContext.ssrContext.cache;\n    } else {\n      const _cache = {};\n      ctx.nuxtContext.cache = {\n        get: id => _cache[id],\n        set: (id, value) => {\n          _cache[id] = value;\n        },\n        has: id => typeof _cache[id] !== \"undefined\"\n      };\n    }\n  }\n  return ctx.nuxtContext.cache;\n}\n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/utils/index.js\nfunction imageFetch(url) {\n  return fetch(cleanDoubleSlashes(url));\n}\nfunction getInt(x) {\n  if (typeof x === \"number\") {\n    return x;\n  }\n  if (typeof x === \"string\") {\n    return parseInt(x, 10);\n  }\n  return void 0;\n}\nfunction getFileExtension(url = \"\") {\n  const extension = url.split(/[?#]/).shift().split(\"/\").pop().split(\".\").pop();\n  return extension;\n}\nfunction cleanDoubleSlashes(path = \"\") {\n  return path.replace(/(https?:\\/\\/)|(\\/)+/g, \"$1$2\");\n}\nfunction createMapper(map) {\n  return key => {\n    return key ? map[key] || key : map.missingValue;\n  };\n}\nfunction createOperationsGenerator({\n  formatter,\n  keyMap,\n  joinWith = \"/\",\n  valueMap\n} = {}) {\n  if (!formatter) {\n    formatter = (key, value) => `${key}=${value}`;\n  }\n  if (keyMap && typeof keyMap !== \"function\") {\n    keyMap = createMapper(keyMap);\n  }\n  const map = valueMap || {};\n  Object.keys(map).forEach(valueKey => {\n    if (typeof map[valueKey] !== \"function\") {\n      map[valueKey] = createMapper(map[valueKey]);\n    }\n  });\n  return (modifiers = {}) => {\n    const operations = Object.entries(modifiers).filter(([_, value]) => typeof value !== \"undefined\").map(([key, value]) => {\n      const mapper = map[key];\n      if (typeof mapper === \"function\") {\n        value = mapper(modifiers[key]);\n      }\n      key = typeof keyMap === \"function\" ? keyMap(key) : key;\n      return formatter(key, value);\n    });\n    return operations.join(joinWith);\n  };\n}\nfunction renderAttributesToString(attributes = {}) {\n  return Object.entries(attributes).map(([key, value]) => value ? `${key}=\"${value}\"` : \"\").filter(Boolean).join(\" \");\n}\nfunction renderTag(tag, attrs, contents) {\n  const html = `<${tag} ${renderAttributesToString(attrs)}>`;\n  if (!contents) {\n    return html;\n  }\n  return html + contents + `</${tag}>`;\n}\nfunction generateAlt(src = \"\") {\n  return src.split(/[?#]/).shift().split(\"/\").pop().split(\".\").shift();\n}\nfunction parseSize(input = \"\") {\n  if (typeof input === \"number\") {\n    return input;\n  }\n  if (typeof input === \"string\") {\n    if (input.replace(\"px\", \"\").match(/^\\d+$/g)) {\n      return parseInt(input, 10);\n    }\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/image.js\n\n\n\n\n\nfunction createImage(globalOptions, nuxtContext) {\n  const staticImageManifest =  false ? undefined : {};\n  const ctx = {\n    options: globalOptions,\n    nuxtContext\n  };\n  const getImage = function (input, options = {}) {\n    const image = resolveImage(ctx, input, options);\n    if (image.isStatic) {\n      handleStaticImage(image, input);\n    }\n    return image;\n  };\n  const $img = function $img2(input, modifiers = {}, options = {}) {\n    return getImage(input, {\n      ...options,\n      modifiers: defu_default()(modifiers, options.modifiers || {})\n    }).url;\n  };\n  function handleStaticImage(image, input) {\n    if (true) {\n      if (false) {}\n      if (true) {\n        const {\n          ssrContext\n        } = ctx.nuxtContext;\n        if (ssrContext) {\n          var _ssrState$data, _ssrContext$image;\n          const ssrState = ssrContext.nuxt || {};\n          const staticImages = ssrState._img = ssrState._img || {};\n          const ssrData = (_ssrState$data = ssrState.data) === null || _ssrState$data === void 0 ? void 0 : _ssrState$data[0];\n          if (ssrData) {\n            ssrData._img = staticImages;\n          }\n          const mapToStatic = (_ssrContext$image = ssrContext.image) === null || _ssrContext$image === void 0 ? void 0 : _ssrContext$image.mapToStatic;\n          if (typeof mapToStatic === \"function\") {\n            const mappedURL = mapToStatic(image, input);\n            if (mappedURL) {\n              staticImages[image.url] = mappedURL;\n              image.url = mappedURL;\n            }\n          }\n        }\n      }\n    } else {}\n  }\n  for (const presetName in globalOptions.presets) {\n    $img[presetName] = (source, modifiers, options) => $img(source, modifiers, {\n      ...globalOptions.presets[presetName],\n      ...options\n    });\n  }\n  $img.options = globalOptions;\n  $img.getImage = getImage;\n  $img.getMeta = (input, options) => getMeta(ctx, input, options);\n  $img.getSizes = (input, options) => getSizes(ctx, input, options);\n  ctx.$img = $img;\n  return $img;\n}\nasync function getMeta(ctx, input, options) {\n  const image = resolveImage(ctx, input, {\n    ...options\n  });\n  if (typeof image.getMeta === \"function\") {\n    return await image.getMeta();\n  } else {\n    return await imageMeta(ctx, image.url);\n  }\n}\nfunction resolveImage(ctx, input, options) {\n  var _options$modifiers, _options$modifiers2;\n  if (typeof input !== \"string\" || input === \"\") {\n    throw new TypeError(`input must be a string (received ${typeof input}: ${JSON.stringify(input)})`);\n  }\n  if (input.startsWith(\"data:\")) {\n    return {\n      url: input\n    };\n  }\n  const {\n    provider,\n    defaults\n  } = getProvider(ctx, options.provider || ctx.options.provider);\n  const preset = getPreset(ctx, options.preset);\n  input = Object(dist[\"hasProtocol\"])(input) ? input : Object(dist[\"withLeadingSlash\"])(input);\n  if (!provider.supportsAlias) {\n    for (const base in ctx.options.alias) {\n      if (input.startsWith(base)) {\n        input = Object(dist[\"joinURL\"])(ctx.options.alias[base], input.substr(base.length));\n      }\n    }\n  }\n  if (provider.validateDomains && Object(dist[\"hasProtocol\"])(input)) {\n    const inputHost = Object(dist[\"parseURL\"])(input).host;\n    if (!ctx.options.domains.find(d => d === inputHost)) {\n      return {\n        url: input\n      };\n    }\n  }\n  const _options = defu_default()(options, preset, defaults);\n  _options.modifiers = {\n    ..._options.modifiers\n  };\n  const expectedFormat = _options.modifiers.format;\n  if ((_options$modifiers = _options.modifiers) !== null && _options$modifiers !== void 0 && _options$modifiers.width) {\n    _options.modifiers.width = parseSize(_options.modifiers.width);\n  }\n  if ((_options$modifiers2 = _options.modifiers) !== null && _options$modifiers2 !== void 0 && _options$modifiers2.height) {\n    _options.modifiers.height = parseSize(_options.modifiers.height);\n  }\n  const image = provider.getImage(input, _options, ctx);\n  image.format = image.format || expectedFormat || \"\";\n  return image;\n}\nfunction getProvider(ctx, name) {\n  const provider = ctx.options.providers[name];\n  if (!provider) {\n    throw new Error(\"Unknown provider: \" + name);\n  }\n  return provider;\n}\nfunction getPreset(ctx, name) {\n  if (!name) {\n    return {};\n  }\n  if (!ctx.options.presets[name]) {\n    throw new Error(\"Unknown preset: \" + name);\n  }\n  return ctx.options.presets[name];\n}\nfunction getSizes(ctx, input, opts) {\n  var _opts$modifiers, _opts$modifiers2;\n  const width = parseSize((_opts$modifiers = opts.modifiers) === null || _opts$modifiers === void 0 ? void 0 : _opts$modifiers.width);\n  const height = parseSize((_opts$modifiers2 = opts.modifiers) === null || _opts$modifiers2 === void 0 ? void 0 : _opts$modifiers2.height);\n  const hwRatio = width && height ? height / width : 0;\n  const variants = [];\n  const sizes = {};\n  if (typeof opts.sizes === \"string\") {\n    for (const entry of opts.sizes.split(/[\\s,]+/).filter(e => e)) {\n      const s = entry.split(\":\");\n      if (s.length !== 2) {\n        continue;\n      }\n      sizes[s[0].trim()] = s[1].trim();\n    }\n  } else {\n    Object.assign(sizes, opts.sizes);\n  }\n  for (const key in sizes) {\n    const screenMaxWidth = ctx.options.screens && ctx.options.screens[key] || parseInt(key);\n    let size = String(sizes[key]);\n    const isFluid = size.endsWith(\"vw\");\n    if (!isFluid && /^\\d+$/.test(size)) {\n      size = size + \"px\";\n    }\n    if (!isFluid && !size.endsWith(\"px\")) {\n      continue;\n    }\n    let _cWidth = parseInt(size);\n    if (!screenMaxWidth || !_cWidth) {\n      continue;\n    }\n    if (isFluid) {\n      _cWidth = Math.round(_cWidth / 100 * screenMaxWidth);\n    }\n    const _cHeight = hwRatio ? Math.round(_cWidth * hwRatio) : height;\n    variants.push({\n      width: _cWidth,\n      size,\n      screenMaxWidth,\n      media: `(max-width: ${screenMaxWidth}px)`,\n      src: ctx.$img(input, {\n        ...opts.modifiers,\n        width: _cWidth,\n        height: _cHeight\n      }, opts)\n    });\n  }\n  variants.sort((v1, v2) => v1.screenMaxWidth - v2.screenMaxWidth);\n  const defaultVar = variants[variants.length - 1];\n  if (defaultVar) {\n    defaultVar.media = \"\";\n  }\n  return {\n    sizes: variants.map(v => `${v.media ? v.media + \" \" : \"\"}${v.size}`).join(\", \"),\n    srcset: variants.map(v => `${v.src} ${v.width}w`).join(\", \"),\n    src: defaultVar === null || defaultVar === void 0 ? void 0 : defaultVar.src\n  };\n}\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/@nuxt/image/dist/runtime/components/nuxt-img.vue?vue&type=template&id=356cdf12&\nvar nuxt_imgvue_type_template_id_356cdf12_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('img',_vm._g(_vm._b({key:_vm.nSrc,attrs:{\"src\":_vm.nSrc}},'img',_vm.nAttrs,false),_vm.$listeners),[])}\nvar nuxt_imgvue_type_template_id_356cdf12_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/components/image.mixin.js\n\nconst defineMixin = opts => opts;\nconst imageMixin = defineMixin({\n  props: {\n    src: {\n      type: String,\n      required: true\n    },\n    format: {\n      type: String,\n      default: void 0\n    },\n    quality: {\n      type: [Number, String],\n      default: void 0\n    },\n    background: {\n      type: String,\n      default: void 0\n    },\n    fit: {\n      type: String,\n      default: void 0\n    },\n    modifiers: {\n      type: Object,\n      default: void 0\n    },\n    preset: {\n      type: String,\n      default: void 0\n    },\n    provider: {\n      type: String,\n      default: void 0\n    },\n    sizes: {\n      type: [Object, String],\n      default: void 0\n    },\n    preload: {\n      type: Boolean,\n      default: void 0\n    },\n    width: {\n      type: [String, Number],\n      default: void 0\n    },\n    height: {\n      type: [String, Number],\n      default: void 0\n    },\n    alt: {\n      type: String,\n      default: void 0\n    },\n    referrerpolicy: {\n      type: String,\n      default: void 0\n    },\n    usemap: {\n      type: String,\n      default: void 0\n    },\n    longdesc: {\n      type: String,\n      default: void 0\n    },\n    ismap: {\n      type: Boolean,\n      default: void 0\n    },\n    crossorigin: {\n      type: [Boolean, String],\n      default: void 0,\n      validator: val => [\"anonymous\", \"use-credentials\", \"\", true, false].includes(val)\n    },\n    loading: {\n      type: String,\n      default: void 0\n    },\n    decoding: {\n      type: String,\n      default: void 0,\n      validator: val => [\"async\", \"auto\", \"sync\"].includes(val)\n    }\n  },\n  computed: {\n    nImgAttrs() {\n      return {\n        width: parseSize(this.width),\n        height: parseSize(this.height),\n        alt: this.alt,\n        referrerpolicy: this.referrerpolicy,\n        usemap: this.usemap,\n        longdesc: this.longdesc,\n        ismap: this.ismap,\n        crossorigin: this.crossorigin === true ? \"anonymous\" : this.crossorigin || void 0,\n        loading: this.loading,\n        decoding: this.decoding\n      };\n    },\n    nModifiers() {\n      return {\n        ...this.modifiers,\n        width: parseSize(this.width),\n        height: parseSize(this.height),\n        format: this.format,\n        quality: this.quality,\n        background: this.background,\n        fit: this.fit\n      };\n    },\n    nOptions() {\n      return {\n        provider: this.provider,\n        preset: this.preset\n      };\n    }\n  }\n});\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--2-0!./node_modules/babel-loader/lib??ref--2-1!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/@nuxt/image/dist/runtime/components/nuxt-img.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n\n\n\nconst defineComponent = opts => opts;\n/* harmony default export */ var nuxt_imgvue_type_script_lang_js_ = (defineComponent({\n  name: \"NuxtImg\",\n  mixins: [imageMixin],\n  head() {\n    if (this.preload === true) {\n      return {\n        link: [{\n          rel: \"preload\",\n          as: \"image\",\n          href: this.nSrc\n        }]\n      };\n    }\n  },\n  computed: {\n    nAttrs() {\n      const attrs = this.nImgAttrs;\n      if (this.sizes) {\n        const {\n          sizes,\n          srcset\n        } = this.nSizes;\n        attrs.sizes = sizes;\n        attrs.srcset = srcset;\n      }\n      return attrs;\n    },\n    nSrc() {\n      return this.sizes ? this.nSizes.src : this.$img(this.src, this.nModifiers, this.nOptions);\n    },\n    nSizes() {\n      return this.$img.getSizes(this.src, {\n        ...this.nOptions,\n        sizes: this.sizes,\n        modifiers: {\n          ...this.nModifiers,\n          width: parseSize(this.width),\n          height: parseSize(this.height)\n        }\n      });\n    }\n  },\n  created() {\n    if (true) {\n      if (this.sizes) {\n        this.nSizes;\n      }\n    }\n  }\n}));\n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/components/nuxt-img.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_nuxt_imgvue_type_script_lang_js_ = (nuxt_imgvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/components/nuxt-img.vue\n\n\n\n\n\n/* normalize component */\n\nvar nuxt_img_component = Object(componentNormalizer[\"a\" /* default */])(\n  components_nuxt_imgvue_type_script_lang_js_,\n  nuxt_imgvue_type_template_id_356cdf12_render,\n  nuxt_imgvue_type_template_id_356cdf12_staticRenderFns,\n  false,\n  null,\n  null,\n  \"4c323b33\"\n  \n)\n\n/* harmony default export */ var nuxt_img = (nuxt_img_component.exports);\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/@nuxt/image/dist/runtime/components/nuxt-picture.vue?vue&type=template&id=88bec26c&\nvar nuxt_picturevue_type_template_id_88bec26c_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('picture',{key:_vm.nSources[0].src},[_vm._ssrNode(((_vm.nSources[1])?(\"<source\"+(_vm._ssrAttr(\"type\",_vm.nSources[1].type))+(_vm._ssrAttr(\"srcset\",_vm.nSources[1].srcset))+(_vm._ssrAttr(\"sizes\",_vm.nSources[1].sizes))+\">\"):\"<!---->\")+\" <img\"+(_vm._ssrAttr(\"src\",_vm.nSources[0].src))+(_vm._ssrAttr(\"srcset\",_vm.nSources[0].srcset))+(_vm._ssrAttr(\"sizes\",_vm.nSources[0].sizes))+(_vm._ssrAttrs(Object.assign({}, _vm.nImgAttrs, _vm.imgAttrs)))+\">\")])}\nvar nuxt_picturevue_type_template_id_88bec26c_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--2-0!./node_modules/babel-loader/lib??ref--2-1!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/@nuxt/image/dist/runtime/components/nuxt-picture.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\nconst nuxt_picturevue_type_script_lang_js_defineComponent = opts => opts;\n/* harmony default export */ var nuxt_picturevue_type_script_lang_js_ = (nuxt_picturevue_type_script_lang_js_defineComponent({\n  name: \"NuxtPicture\",\n  mixins: [imageMixin],\n  props: {\n    legacyFormat: {\n      type: String,\n      default: null\n    },\n    imgAttrs: {\n      type: Object,\n      default: null\n    }\n  },\n  head() {\n    if (this.preload === true) {\n      const srcKey = typeof this.nSources[1] !== \"undefined\" ? 1 : 0;\n      const link = {\n        rel: \"preload\",\n        as: \"image\",\n        imagesrcset: this.nSources[srcKey].srcset\n      };\n      if (typeof this.nSources[srcKey].sizes !== \"undefined\") {\n        link.imagesizes = this.nSources[srcKey].sizes;\n      }\n      return {\n        link: [link]\n      };\n    }\n  },\n  computed: {\n    isTransparent() {\n      return [\"png\", \"webp\", \"gif\"].includes(this.originalFormat);\n    },\n    originalFormat() {\n      return getFileExtension(this.src);\n    },\n    nFormat() {\n      if (this.format) {\n        return this.format;\n      }\n      if (this.originalFormat === \"svg\") {\n        return \"svg\";\n      }\n      return \"webp\";\n    },\n    nLegacyFormat() {\n      if (this.legacyFormat) {\n        return this.legacyFormat;\n      }\n      const formats = {\n        webp: this.isTransparent ? \"png\" : \"jpeg\",\n        svg: \"png\"\n      };\n      return formats[this.nFormat] || this.originalFormat;\n    },\n    nSources() {\n      if (this.nFormat === \"svg\") {\n        return [{\n          srcset: this.src\n        }];\n      }\n      const formats = this.nLegacyFormat !== this.nFormat ? [this.nLegacyFormat, this.nFormat] : [this.nFormat];\n      const sources = formats.map(format => {\n        const {\n          srcset,\n          sizes,\n          src\n        } = this.$img.getSizes(this.src, {\n          ...this.nOptions,\n          sizes: this.sizes || this.$img.options.screens,\n          modifiers: {\n            ...this.nModifiers,\n            format\n          }\n        });\n        return {\n          src,\n          type: `image/${format}`,\n          sizes,\n          srcset\n        };\n      });\n      return sources;\n    }\n  },\n  created() {\n    if (true) {\n      this.nSources;\n    }\n  }\n}));\n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/components/nuxt-picture.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_nuxt_picturevue_type_script_lang_js_ = (nuxt_picturevue_type_script_lang_js_); \n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/components/nuxt-picture.vue\n\n\n\n\n\n/* normalize component */\n\nvar nuxt_picture_component = Object(componentNormalizer[\"a\" /* default */])(\n  components_nuxt_picturevue_type_script_lang_js_,\n  nuxt_picturevue_type_template_id_88bec26c_render,\n  nuxt_picturevue_type_template_id_88bec26c_staticRenderFns,\n  false,\n  null,\n  null,\n  \"4318feee\"\n  \n)\n\n/* harmony default export */ var nuxt_picture = (nuxt_picture_component.exports);\n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/providers/ipx.js\n\n\nconst operationsGenerator = createOperationsGenerator({\n  keyMap: {\n    format: \"f\",\n    fit: \"fit\",\n    width: \"w\",\n    height: \"h\",\n    resize: \"s\",\n    quality: \"q\",\n    background: \"b\"\n  },\n  joinWith: \",\",\n  formatter: (key, val) => Object(dist[\"encodeParam\"])(key) + \"_\" + Object(dist[\"encodeParam\"])(val)\n});\nconst ipx_getImage = (src, {\n  modifiers = {},\n  baseURL = \"/_ipx\"\n} = {}, {\n  nuxtContext: {\n    base: nuxtBase = \"/\"\n  } = {}\n}) => {\n  if (modifiers.width && modifiers.height) {\n    modifiers.resize = `${modifiers.width}x${modifiers.height}`;\n    delete modifiers.width;\n    delete modifiers.height;\n  }\n  const params = operationsGenerator(modifiers) || \"_\";\n  return {\n    url: Object(dist[\"joinURL\"])(nuxtBase, baseURL, params, Object(dist[\"encodePath\"])(src))\n  };\n};\nconst validateDomains = true;\nconst supportsAlias = true;\n// CONCATENATED MODULE: ./node_modules/@nuxt/image/dist/runtime/providers/static.js\n\nconst static_getImage = (src, options, ctx) => ({\n  ...ipx_getImage(src, options, ctx),\n  isStatic: true\n});\nconst static_supportsAlias = true;\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/image.js\n\n\n\n\n\nconst imageOptions = {\n  \"screens\": {\n    \"xs\": 320,\n    \"sm\": 640,\n    \"md\": 768,\n    \"lg\": 1024,\n    \"xl\": 1280,\n    \"xxl\": 1536,\n    \"2xl\": 1536\n  },\n  \"presets\": {},\n  \"provider\": \"static\",\n  \"domains\": [],\n  \"alias\": {}\n};\nimageOptions.providers = {\n  ['static']: {\n    provider: static_namespaceObject,\n    defaults: {}\n  }\n};\nexternal_vue_default.a.component(nuxt_img.name, nuxt_img);\nexternal_vue_default.a.component(nuxt_picture.name, nuxt_picture);\nexternal_vue_default.a.component('NImg', nuxt_img);\nexternal_vue_default.a.component('NPicture', nuxt_picture);\n/* harmony default export */ var nuxt_image = (function (nuxtContext, inject) {\n  const $img = createImage(imageOptions, nuxtContext);\n  if (true) {\n    nuxtContext.beforeNuxtRender(({\n      nuxtState\n    }) => {\n      const ssrData = nuxtState.data[0] || {};\n      ssrData._img = nuxtState._img || {};\n    });\n  }\n  inject('img', $img);\n});\n// EXTERNAL MODULE: external \"gsap\"\nvar external_gsap_ = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/gsapModule.js\n\n\nexternal_vue_default.a.directive('gsap', (el, binding) => {\n  const options = {\n    ...binding.value\n  };\n  const modifiers = binding.modifiers;\n  if (modifiers.set) {\n    external_gsap_[\"gsap\"].set(el, options);\n  }\n  if (modifiers.to) {\n    external_gsap_[\"gsap\"].to(el, options);\n  }\n  if (modifiers.from) {\n    external_gsap_[\"gsap\"].from(el, options);\n  }\n  if (modifiers.fromTo) {\n    external_gsap_[\"gsap\"].fromTo(el, {\n      ...binding.value[0]\n    }, {\n      ...binding.value[1]\n    });\n  }\n});\n/* harmony default export */ var gsapModule = (({\n  app\n}, inject) => {\n  inject('gsap', external_gsap_[\"gsap\"]);\n  if (false) {}\n});\n// CONCATENATED MODULE: ./plugins/nuxt/prefers-reduced-motion.js\n/* harmony default export */ var prefers_reduced_motion = ((_, inject) => {\n  const checkReducedMotion = () => typeof window === 'undefined' ? false : window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n  inject('prefersReducedMotion', checkReducedMotion);\n});\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/index.js\n\n\n\n\n\n\n\n\n\n\n\n/* Plugins */\n\n // Source: ./components/plugin.js (mode: 'all')\n // Source: ./content/plugin.client.js (mode: 'client')\n // Source: ./content/plugin.server.js (mode: 'server')\n // Source: ./image.js (mode: 'all')\n // Source: ./gsapModule.js (mode: 'all')\n // Source: ../../../plugins/nuxt/hover-directive.client.js (mode: 'client')\n // Source: ../../../plugins/nuxt/prefers-reduced-motion.js (mode: 'all')\n // Source: ../../../plugins/nuxt/smooth-scroll.client.js (mode: 'client')\n\n// Component: <ClientOnly>\nexternal_vue_default.a.component(external_vue_client_only_default.a.name, external_vue_client_only_default.a);\n\n// TODO: Remove in Nuxt 3: <NoSsr>\nexternal_vue_default.a.component(external_vue_no_ssr_default.a.name, {\n  ...external_vue_no_ssr_default.a,\n  render(h, ctx) {\n    if (false) {}\n    return external_vue_no_ssr_default.a.render(h, ctx);\n  }\n});\n\n// Component: <NuxtChild>\nexternal_vue_default.a.component(nuxt_child.name, nuxt_child);\nexternal_vue_default.a.component('NChild', nuxt_child);\n\n// Component NuxtLink is imported in server.js or client.js\n\n// Component: <Nuxt>\nexternal_vue_default.a.component(components_nuxt.name, components_nuxt);\nObject.defineProperty(external_vue_default.a.prototype, '$nuxt', {\n  get() {\n    return this.$root.$options.$nuxt;\n  },\n  configurable: true\n});\nexternal_vue_default.a.use(external_vue_meta_default.a, {\n  \"keyName\": \"head\",\n  \"attribute\": \"data-n-head\",\n  \"ssrAttribute\": \"data-n-head-ssr\",\n  \"tagIDKeyName\": \"hid\"\n});\nconst defaultTransition = {\n  \"name\": \"page\",\n  \"mode\": \"out-in\",\n  \"appear\": false,\n  \"appearClass\": \"appear\",\n  \"appearActiveClass\": \"appear-active\",\n  \"appearToClass\": \"appear-to\"\n};\nasync function createApp(ssrContext, config = {}) {\n  const router = await createRouter(ssrContext, config);\n\n  // Create Root instance\n\n  // here we inject the router and store to all child components,\n  // making them available everywhere as `this.$router` and `this.$store`.\n  const app = {\n    head: {\n      \"htmlAttrs\": {\n        \"lang\": \"en\",\n        \"dir\": \"ltr\"\n      },\n      \"title\": \"Diane Bouffard-Vercelli | Portfolio\",\n      \"meta\": [{\n        \"charset\": \"utf8\"\n      }, {\n        \"http-equiv\": \"X-UA-Compatible\",\n        \"content\": \"IE=edge\"\n      }, {\n        \"name\": \"viewport\",\n        \"content\": \"width=device-width, initial-scale=1.0\"\n      }],\n      \"link\": [],\n      \"style\": [],\n      \"script\": []\n    },\n    router,\n    nuxt: {\n      defaultTransition,\n      transitions: [defaultTransition],\n      setTransitions(transitions) {\n        if (!Array.isArray(transitions)) {\n          transitions = [transitions];\n        }\n        transitions = transitions.map(transition => {\n          if (!transition) {\n            transition = defaultTransition;\n          } else if (typeof transition === 'string') {\n            transition = Object.assign({}, defaultTransition, {\n              name: transition\n            });\n          } else {\n            transition = Object.assign({}, defaultTransition, transition);\n          }\n          return transition;\n        });\n        this.$options.nuxt.transitions = transitions;\n        return transitions;\n      },\n      err: null,\n      dateErr: null,\n      error(err) {\n        err = err || null;\n        app.context._errored = Boolean(err);\n        err = err ? normalizeError(err) : null;\n        let nuxt = app.nuxt; // to work with @vue/composition-api, see https://github.com/nuxt/nuxt.js/issues/6517#issuecomment-573280207\n        if (this) {\n          nuxt = this.nuxt || this.$options.nuxt;\n        }\n        nuxt.dateErr = Date.now();\n        nuxt.err = err;\n        // Used in src/server.js\n        if (ssrContext) {\n          ssrContext.nuxt.error = err;\n        }\n        return err;\n      }\n    },\n    ...App\n  };\n  const next = ssrContext ? ssrContext.next : location => app.router.push(location);\n  // Resolve route\n  let route;\n  if (ssrContext) {\n    route = router.resolve(ssrContext.url).route;\n  } else {\n    const path = getLocation(router.options.base, router.options.mode);\n    route = router.resolve(path).route;\n  }\n\n  // Set context to app.context\n  await setContext(app, {\n    route,\n    next,\n    error: app.nuxt.error.bind(app),\n    payload: ssrContext ? ssrContext.payload : undefined,\n    req: ssrContext ? ssrContext.req : undefined,\n    res: ssrContext ? ssrContext.res : undefined,\n    beforeRenderFns: ssrContext ? ssrContext.beforeRenderFns : undefined,\n    ssrContext\n  });\n  function inject(key, value) {\n    if (!key) {\n      throw new Error('inject(key, value) has no key provided');\n    }\n    if (value === undefined) {\n      throw new Error(`inject('${key}', value) has no value provided`);\n    }\n    key = '$' + key;\n    // Add into app\n    app[key] = value;\n    // Add into context\n    if (!app.context[key]) {\n      app.context[key] = value;\n    }\n\n    // Check if plugin not already installed\n    const installKey = '__nuxt_' + key + '_installed__';\n    if (external_vue_default.a[installKey]) {\n      return;\n    }\n    external_vue_default.a[installKey] = true;\n    // Call Vue.use() to install the plugin into vm\n    external_vue_default.a.use(() => {\n      if (!Object.prototype.hasOwnProperty.call(external_vue_default.a.prototype, key)) {\n        Object.defineProperty(external_vue_default.a.prototype, key, {\n          get() {\n            return this.$root.$options[key];\n          }\n        });\n      }\n    });\n  }\n\n  // Inject runtime config as $config\n  inject('config', config);\n\n  // Add enablePreview(previewData = {}) in context for plugins\n  if (false) {}\n  // Plugin execution\n\n  if (typeof /* Cannot get final name for export \"default\" in \"./node_modules/.cache/nuxt/components/plugin.js\" (known exports: , known reexports: ) */ undefined === 'function') {\n    await /* Cannot get final name for export \"default\" in \"./node_modules/.cache/nuxt/components/plugin.js\" (known exports: , known reexports: ) */ undefined(app.context, inject);\n  }\n  if (false) {}\n  if ( true && typeof plugin_server === 'function') {\n    await plugin_server(app.context, inject);\n  }\n  if (typeof nuxt_image === 'function') {\n    await nuxt_image(app.context, inject);\n  }\n  if (typeof gsapModule === 'function') {\n    await gsapModule(app.context, inject);\n  }\n  if (false) {}\n  if (typeof prefers_reduced_motion === 'function') {\n    await prefers_reduced_motion(app.context, inject);\n  }\n  if (false) {}\n\n  // Lock enablePreview in context\n  if (false) {}\n\n  // If server-side, wait for async component to be resolved first\n  if ( true && ssrContext && ssrContext.url) {\n    await new Promise((resolve, reject) => {\n      router.push(ssrContext.url, resolve, err => {\n        // https://github.com/vuejs/vue-router/blob/v3.4.3/src/util/errors.js\n        if (!err._isRouter) return reject(err);\n        if (err.type !== 2 /* NavigationFailureType.redirected */) return resolve();\n\n        // navigated to a different route in router guard\n        const unregister = router.afterEach(async (to, from) => {\n          ssrContext.url = to.fullPath;\n          app.context.route = await getRouteData(to);\n          app.context.params = to.params || {};\n          app.context.query = to.query || {};\n          unregister();\n          resolve();\n        });\n      });\n    });\n  }\n  return {\n    app,\n    router\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-link.server.js\n\n/* harmony default export */ var nuxt_link_server = ({\n  name: 'NuxtLink',\n  extends: external_vue_default.a.component('RouterLink'),\n  props: {\n    prefetch: {\n      type: Boolean,\n      default: true\n    },\n    noPrefetch: {\n      type: Boolean,\n      default: false\n    }\n  }\n});\n// CONCATENATED MODULE: ./node_modules/.cache/nuxt/server.js\n\n\n\n\n\n\n\n // should be included after ./index.js\n\n// Update serverPrefetch strategy\nexternal_vue_default.a.config.optionMergeStrategies.serverPrefetch = external_vue_default.a.config.optionMergeStrategies.created;\n\n// Fetch mixin\nif (!external_vue_default.a.__nuxt__fetch__mixin__) {\n  external_vue_default.a.mixin(fetch_server);\n  external_vue_default.a.__nuxt__fetch__mixin__ = true;\n}\n\n// Component: <NuxtLink>\nexternal_vue_default.a.component(nuxt_link_server.name, nuxt_link_server);\nexternal_vue_default.a.component('NLink', nuxt_link_server);\nif (!global.fetch) {\n  global.fetch = external_node_fetch_default.a;\n}\nconst noopApp = () => new external_vue_default.a({\n  render: h => h('div', {\n    domProps: {\n      id: '__nuxt'\n    }\n  })\n});\nconst createNext = ssrContext => opts => {\n  // If static target, render on client-side\n  ssrContext.redirected = opts;\n  if (ssrContext.target === 'static' || !ssrContext.res) {\n    ssrContext.nuxt.serverRendered = false;\n    return;\n  }\n  let fullPath = Object(dist[\"withQuery\"])(opts.path, opts.query);\n  const $config = ssrContext.runtimeConfig || {};\n  const routerBase = $config.app && $config.app.basePath || '/home/';\n  if (!fullPath.startsWith('http') && routerBase !== '/' && !fullPath.startsWith(routerBase)) {\n    fullPath = Object(dist[\"joinURL\"])(routerBase, fullPath);\n  }\n  // Avoid loop redirect\n  if (decodeURI(fullPath) === decodeURI(ssrContext.url)) {\n    ssrContext.redirected = false;\n    return;\n  }\n  ssrContext.res.writeHead(opts.status, {\n    Location: Object(dist[\"normalizeURL\"])(fullPath)\n  });\n  ssrContext.res.end();\n};\n\n// This exported function will be called by `bundleRenderer`.\n// This is where we perform data-prefetching to determine the\n// state of our application before actually rendering it.\n// Since data fetching is async, this function is expected to\n// return a Promise that resolves to the app instance.\n/* harmony default export */ var server = __webpack_exports__[\"default\"] = (async ssrContext => {\n  // Create ssrContext.next for simulate next() of beforeEach() when wanted to redirect\n  ssrContext.redirected = false;\n  ssrContext.next = createNext(ssrContext);\n  // Used for beforeNuxtRender({ Components, nuxtState })\n  ssrContext.beforeRenderFns = [];\n  // Nuxt object (window.{{globals.context}}, defaults to window.__NUXT__)\n  ssrContext.nuxt = {\n    layout: 'default',\n    data: [],\n    fetch: {},\n    error: null,\n    serverRendered: true,\n    routePath: ''\n  };\n  ssrContext.fetchCounters = {};\n\n  // Remove query from url is static target\n\n  if (ssrContext.url) {\n    ssrContext.url = ssrContext.url.split('?')[0];\n  }\n\n  // Public runtime config\n  ssrContext.nuxt.config = ssrContext.runtimeConfig.public;\n  if (ssrContext.nuxt.config.app) {\n    __webpack_require__.p = Object(dist[\"joinURL\"])(ssrContext.nuxt.config.app.cdnURL, ssrContext.nuxt.config.app.assetsPath);\n  }\n  // Create the app definition and the instance (created for each request)\n  const {\n    app,\n    router\n  } = await createApp(ssrContext, ssrContext.runtimeConfig.private);\n  const _app = new external_vue_default.a(app);\n  // Add ssr route path to nuxt context so we can account for page navigation between ssr and csr\n  ssrContext.nuxt.routePath = app.context.route.path;\n\n  // Add meta infos (used in renderer.js)\n  ssrContext.meta = _app.$meta();\n\n  // Keep asyncData for each matched component in ssrContext (used in app/utils.js via this.$ssrContext)\n  ssrContext.asyncData = {};\n  const beforeRender = async () => {\n    // Call beforeNuxtRender() methods\n    await Promise.all(ssrContext.beforeRenderFns.map(fn => promisify(fn, {\n      Components,\n      nuxtState: ssrContext.nuxt\n    })));\n  };\n  const renderErrorPage = async () => {\n    // Don't server-render the page in static target\n    if (ssrContext.target === 'static') {\n      ssrContext.nuxt.serverRendered = false;\n    }\n\n    // Load layout for error page\n    const layout = (nuxt_error.options || nuxt_error).layout;\n    const errLayout = typeof layout === 'function' ? layout.call(nuxt_error, app.context) : layout;\n    ssrContext.nuxt.layout = errLayout || 'default';\n    await _app.loadLayout(errLayout);\n    _app.setLayout(errLayout);\n    await beforeRender();\n    return _app;\n  };\n  const render404Page = () => {\n    app.context.error({\n      statusCode: 404,\n      path: ssrContext.url,\n      message: 'This page could not be found'\n    });\n    return renderErrorPage();\n  };\n\n  // Components are already resolved by setContext -> getRouteData (app/utils.js)\n  const Components = getMatchedComponents(router.match(ssrContext.url));\n\n  /*\n  ** Call global middleware (nuxt.config.js)\n  */\n  let midd = [];\n  midd = midd.map(name => {\n    if (typeof name === 'function') {\n      return name;\n    }\n    if (typeof nuxt_middleware[name] !== 'function') {\n      app.context.error({\n        statusCode: 500,\n        message: 'Unknown middleware ' + name\n      });\n    }\n    return nuxt_middleware[name];\n  });\n  await middlewareSeries(midd, app.context);\n  // ...If there is a redirect or an error, stop the process\n  if (ssrContext.redirected) {\n    return noopApp();\n  }\n  if (ssrContext.nuxt.error) {\n    return renderErrorPage();\n  }\n\n  /*\n  ** Set layout\n  */\n  let layout = Components.length ? Components[0].options.layout : nuxt_error.layout;\n  if (typeof layout === 'function') {\n    layout = layout(app.context);\n  }\n  await _app.loadLayout(layout);\n  if (ssrContext.nuxt.error) {\n    return renderErrorPage();\n  }\n  layout = _app.setLayout(layout);\n  ssrContext.nuxt.layout = _app.layoutName;\n\n  /*\n  ** Call middleware (layout + pages)\n  */\n  midd = [];\n  layout = sanitizeComponent(layout);\n  if (layout.options.middleware) {\n    midd = midd.concat(layout.options.middleware);\n  }\n  Components.forEach(Component => {\n    if (Component.options.middleware) {\n      midd = midd.concat(Component.options.middleware);\n    }\n  });\n  midd = midd.map(name => {\n    if (typeof name === 'function') {\n      return name;\n    }\n    if (typeof nuxt_middleware[name] !== 'function') {\n      app.context.error({\n        statusCode: 500,\n        message: 'Unknown middleware ' + name\n      });\n    }\n    return nuxt_middleware[name];\n  });\n  await middlewareSeries(midd, app.context);\n  // ...If there is a redirect or an error, stop the process\n  if (ssrContext.redirected) {\n    return noopApp();\n  }\n  if (ssrContext.nuxt.error) {\n    return renderErrorPage();\n  }\n\n  /*\n  ** Call .validate()\n  */\n  let isValid = true;\n  try {\n    for (const Component of Components) {\n      if (typeof Component.options.validate !== 'function') {\n        continue;\n      }\n      isValid = await Component.options.validate(app.context);\n      if (!isValid) {\n        break;\n      }\n    }\n  } catch (validationError) {\n    // ...If .validate() threw an error\n    app.context.error({\n      statusCode: validationError.statusCode || '500',\n      message: validationError.message\n    });\n    return renderErrorPage();\n  }\n\n  // ...If .validate() returned false\n  if (!isValid) {\n    // Render a 404 error page\n    return render404Page();\n  }\n\n  // If no Components found, returns 404\n  if (!Components.length) {\n    return render404Page();\n  }\n\n  // Call asyncData & fetch hooks on components matched by the route.\n  const asyncDatas = await Promise.all(Components.map(Component => {\n    const promises = [];\n\n    // Call asyncData(context)\n    if (Component.options.asyncData && typeof Component.options.asyncData === 'function') {\n      const promise = promisify(Component.options.asyncData, app.context);\n      promise.then(asyncDataResult => {\n        ssrContext.asyncData[Component.cid] = asyncDataResult;\n        applyAsyncData(Component);\n        return asyncDataResult;\n      });\n      promises.push(promise);\n    } else {\n      promises.push(null);\n    }\n\n    // Call fetch(context)\n    if (Component.options.fetch && Component.options.fetch.length) {\n      promises.push(Component.options.fetch(app.context));\n    } else {\n      promises.push(null);\n    }\n    return Promise.all(promises);\n  }));\n\n  // datas are the first row of each\n  ssrContext.nuxt.data = asyncDatas.map(r => r[0] || {});\n\n  // ...If there is a redirect or an error, stop the process\n  if (ssrContext.redirected) {\n    return noopApp();\n  }\n  if (ssrContext.nuxt.error) {\n    return renderErrorPage();\n  }\n\n  // Call beforeNuxtRender methods & add store state\n  await beforeRender();\n  return _app;\n});\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.string.at.js\");\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.weak-map.delete-all.js\");\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.array.last-index.js\");\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.delete-all.js\");\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.every.js\");\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.filter.js\");\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.find.js\");\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.find-key.js\");\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.includes.js\");\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.key-of.js\");\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.map-keys.js\");\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.map-values.js\");\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.merge.js\");\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.reduce.js\");\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.some.js\");\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.map.update.js\");\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.add-all.js\");\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.delete-all.js\");\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.difference.js\");\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.every.js\");\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.filter.js\");\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.find.js\");\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.intersection.js\");\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.is-disjoint-from.js\");\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.is-subset-of.js\");\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.is-superset-of.js\");\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.join.js\");\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.map.js\");\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.reduce.js\");\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.some.js\");\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.symmetric-difference.js\");\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"core-js/modules/esnext.set.union.js\");\n\n/***/ }),\n/* 58 */,\n/* 59 */,\n/* 60 */,\n/* 61 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"image-meta\");\n\n/***/ })\n/******/ ]);"],"mappings":"AAAA;","sourceRoot":""}